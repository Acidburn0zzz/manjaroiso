#!/bin/bash

# Basis settings
TITLE="Manjaro Linux Installation Framework (testing)"
PKG_OVERLAY="/opt/manjaro/pkgs"
#DIALOGRC="./setuprc"
manjaro_kernel="linux"
manjaro_version="2012.10"
code_name="Manjaro"
hostname="manjaro"

# Translation
_yes="Yes"
_no="No"
_cancel="Cancel"
_continue_label="Continue"
_grubdetectdisks="Generating GRUB2 device map...\n\n Please be patient."
_errorfscreate="Error creating filesystem"
_errormounting="Error mounting"
_mkswaperr="Error creating swap:"
_swaponerr="Error activating swap:"
_umountingall="Disabling swapspace, unmounting already mounted disk devices..."
_presentlyavaildisks="Available disks:"
_selectdisktouse="Select the hard drive to use"
_enterbootpartsize="Enter the size (MiB) of your /boot partition.  Minimum is 50."
_diskspaceleft="Disk space left:"
_errorincorrectsize="ERROR: You entered an invalid size, please enter again."
_errorsizetoobig="ERROR: You entered a too small or large size, please enter again."
_enterswappartsize="Enter the size (MiB) of your swap partition."
_enterrootpartsize="Enter the size (MiB) of your / (root) partition.  The /home partition will use the remaining space."
_homepartsize="Size of /home partition:"
_selecthomerootfs="Select a filesystem for / and /home partitions:"
_fshomeroottobeused="will be used for / and /home. OK?"
_willbeerased='will be COMPLETELY ERASED! Proceed?'
_alreadyprepparts='You have already prepared your partitions!'
_invaliddevice="Invalid device:"
_invaliddestdir="Destination directory invalid:"
_onlyonerootpart="We need exactly one root partition"
_partitioningdev="Partitioning"
_errorpartitioningdev="Error partitioning"
_errordetails="Details displayed on"
_preparationfinished='Preparation finished !'
_partsalreadyprepared='You have already prepared your filesystems !'
_done_entry="DONE"
_other_entry="OTHER"
_none_entry="NONE"
_selectdisktopart="Select the disk to partition (or $_done_entry when you have finished)"
_enterdiskpath="Enter the full path to the device you wish to partition"
_prepartitionmessage="You will now partition the selected disk with cfdisk.\nIf it asks you to reboot, do it, launch this program again and restart installation."
_nowchooseparts2use="You will now select the partitions to use."
_selectswappart="Select the partition to use as swap"
_formatpart="Format"
_allcontentswillbelost='Its contents will be erased!'
_selecttherootpart="Select the partition for / (root)"
_selectfsfor="Select the filesystem for"
_wannamountotherparts="Do you want to mount other static partitions at bootup ? (optional)"
_selectmpoint="Select the mountpoint (directory) for"
_twopartsonamp='ERROR: two partitions on the same directory!'
_formatconfirmmessage="Continue?\n\nSyntax\n------\nDEVICE:TYPE:MOUNTPOINT:FORMAT"
_creatingactswap="Creating and activating swap on"
_activatingswapon="Activating swap on"
_formattingpart="Formatting"
_mountingparton="mounting on"
_mountingpart="Mounting"
_partsmountsuccess="Partitions were successfully mounted."

_givecorrectname="Please enter a valid username.\n ==> Tip: lowercase, can't start with a figure"
_givename="Enter the new username"
_givepass="Type the pasword for the new user :"
_addsudouserdl1="Should User \""
_addsudouserdl2="\" get sudo rights?"

_installationwillstart='Installation will now start. Please be patient!'
_installationinprogress="Installation in progress..."
_installationfail='Installation failed!'
_installationsuccess='Installation succeeded!'

_configuringsystem="Configuration in progress..."
_addonsinsttitle=" ==== Addons installation ===="
_wichaddonsinstall="Which addons do you want to install?"
_whichaddonsinst1='1) Choose among available installable addons'
_whichaddonsinst2='2) Install installable addons among currently mounted addons'
_whichaddonsinstn="n) Don't install any add-on"
_installthisaddon="install? [y/N]"
_addoninstalled="installed."
_wantcplivehome="Do you want to copy the current personal folder into the installation? [y/n]"
_wantcplivechg="Do you want to copy into the installation the changes done in live? [y/n]"
_livechg_rwroot="This means the contents of your rwroot folder."
_pressentercont="Press enter to continue..."

_isgrubinst="Is GRUB2 installed? Cannot find"
_autodetectrootfail="Root partition autodetection failed.  Modify manually"
_youwilleditmenulst="You will now edit the GRUB2 configuration file (grub.cfg). You just have to check, everything should be already configured."
_nohdfound="No hard disk found"
_whereinststage1="Where do you want to install GRUB2's stage1? (most of the time on the MBR, i.e. /dev/sda)."
_installinggrub="Installing GRUB2..."
_missingrootpart="Error: missing/invalid root device:"
_cannotfindgrub="GRUB2 root and setup devices could not be auto-located.  You will need to manually run the GRUB2 shell to install a bootloader."
_bootsonanydisk="useful if you change your hard disk/mainboard"
_chainloadexpl="Optional entry for the system on sda1"
_enterrootdevpath="Enter the path of the root partition"
_errorinstgrub="Error installing GRUB2."
_instgrubsuccess="GRUB2 successfully installed."

_machinetimezone="Set the machine time to UTC universal time (recommended) or local time (if you have a dual-boot with a system requiring it)?"
_selectregion="Please select a region"
_selecttimezone="Please select a timezone"
_choosedatetime="Set the date.\nUse <TAB> to navigate and arrow keys to change values."
_choosehourtime="Set the time.\nUse <TAB> to navigate and up/down to change values."

_diskpreparation="Hard disk(s) preparation"
_assistprepa="Assisted preparation (erases the whole disk)"
_manualpartit="Partition by hand and choose the partitions to use"
_mainmenulabel="Main menu"
_runninginitcpio="Running mkinitcpio..."
_runninginitcpiotitle="Building initramfs image..."
_mkinitcpiofailerror="ERROR - You will have to run mkinitcpio by hand, either way the system may not boot."

_localegen="Generating locales..."
_syncpacmandb="Synchronising pacman databases..."
_updatemirrorlist="Updating pacman mirrorlist..."
_setupalsa="Configuring ALSA..."
_installvideodriver="MHWD is installing your video driver(s)..."
_setupsystemd="Configuring SystemD..."
_setupdisplaymanager="Configuring the display manager..."
_fixapps="Fixing some applications..."

_unsquash_dialog_title="Installing system files..."
_unsquash_dialog_info1="Unsquashing archive:"
_unsquash_dialog_info2="\nPlease wait..."
_unsquasherror_title="Unsquashing failed..."

_passwdtitle="Password setup..."
_passwddl="Enter your password for:"
_passwddl1="Enter your password for:"
_passwddl2="Re-Enter your password for:"
_passwddl3="Password don't match!\nRe-Enter your password for:"
  
_definerootpass="Change root password"
_defineuser="Setup user account(s)"
_defineuserpass="Change user password"
_definelocale="Change locale (optional)"
_definekeymap="Change vconsole keymap (optional)"
_enterusername="Enter user account name..."
_doeditconfig="Edit system configuration (optional)"
_return_label="Back"
_rcconftext="Main system configuration"
_fstabtext="Mount points (please check)"
_mkinitcpioconftext="Initramfs config (can be lightened)"
_modprobeconftext="Module options (special cases only)"
_resolvconftext="DNS servers (managed by networkmanager)"
_hostnametext="Network hostname (Systems hostname)"
_hoststext="Network hosts (local DNS)"
_hostsdenytext="Blocked network services"
_hostsallowtext="Authorized network services"
_localegentext="Edit system languages"
_localeconftext="Edit default used language"
_environmenttext="Edit environment language"
_mirrorlisttext="Packages mirror list"
_xorgevdevconftext="Xorg keymap"
_xorgkblayouttext="Xorg keyboard layout"
_vconsoletext="Console keyboard layout"
_installabootloader="Install a bootloader?"
_installgrubbl='Install GRUB2 (needed to boot)'
_installnobl="If you know what you're doing."
_installgrubdl1="Grub2 will be installed with followed settings:\n -> Boot partition:"
_installgrubdl2=" -> Target partition (MBR):"
_installgrubdl3="Is this correct? If not answer with \"No\" to change your target partition, else continue with \"Yes\"."

_none_label="None"

_mainmenuhelp="Use ↓ and ↑ to choose an entry, enter to launch it." 
_datetimetext="Set date and time"
_networktext="Set up Network"
_preparediskstext="Disk(s) preparation"
_installsystemtext="Install system"
_configuresystemtext="Configure system"
_instbootloadertext="Install bootloader"
_quittext="Quit"
_installationfinished='Installation finished!'
_cancelinstall="Cancel installation?"
_instwelcomemessage="Welcome to the TESTING Manjaro Linux CLI installation program. \nThis version might not work for you installing Manjaro to your harddrive. \nSome features aren't fully tested yet. Good luck!"
_forgotsystemconf="Information\n\nYou forgot to configurate your system."
_forgotinstalling="Information\n\nInstalling before configuring would seem more logical."
_forgotpreparehd="Information\n\nPrepare your HDD first."

ANSWER="/tmp/.setup"
# use the first VT not dedicated to a running console
LOG="/dev/tty8"
# don't use /mnt because it's intended to mount other things there!
mkdir -p /install
DESTDIR="/install"
arch=$(uname -m)
EDITOR="nano"
_BLKID="blkid -c /dev/null"

# name of the kernel image
VMLINUZ="vmlinuz-$(expac -Q '%v' linux35)-${arch}-manjaro"
# name of the initramfs filesystem
INITRAMFS="initramfs-$(expac -Q '%v' linux35)-${arch}-manjaro"

# abstract the common pacman args
PACMAN="pacman --root ${DESTDIR} --config /etc/pacman.conf --noconfirm --noprogressbar"
PACMAN_LNG="pacman --root ${DESTDIR} --config /opt/manjaro/pacman-lng.conf --noconfirm --noprogressbar"

# sources
SYNC_URL=
MIRRORLIST="/etc/pacman.d/mirrorlist"
PACKAGES=

# clock
HARDWARECLOCK="localtime"
TIMEZONE="America/Montreal"

# destination of blockdevices in /sys
block="/sys/block"

# partitions
PART_ROOT=""
ROOTFS=""

# check if we have a internet connection
ping_check=$(LC_ALL=C ping -c 1 www.manjaro.org | grep "1 received")

# install stages
S_SRC=0         # choose install medium
S_NET=0         # network configuration
S_CLOCK=0       # clock and timezone
S_PART=0        # partitioning
S_MKFS=0        # formatting
S_MKFSAUTO=0    # auto fs part/formatting
S_SELECT=0      # package selection
S_INSTALL=0     # package installation
S_CONFIG=0      # configuration editing
S_PRECONFIG=0   # pre configuration editing


# main menu selection tracker
NEXTITEM=""

DIALOG() {
   # parameters: see dialog(1)
   # returns: whatever dialog did
   dialog --backtitle "$TITLE" --aspect 15 --yes-label "$_yes" --no-label "$_no" --cancel-label "$_cancel" "$@"
   return $?
}

# kernel_cmdline <param> <default>
# Looks for a parameter on the kernel's boot-time command line.
#
# returns: 0 if param was found. Also prints its value if it was a K=V param.
#          1 if it was not. Also prints value passed as <default>
#
kernel_cmdline ()
{
    for param in $(/bin/cat /proc/cmdline); do
        case "${param}" in
            $1=*) echo "${param##*=}"; return 0 ;;
            $1) return 0 ;;
            *) continue ;;
        esac
    done
    [ -n "${2}" ] && echo "${2}"
    return 1
}

# chroot_mount()
# prepares target system as a chroot
#
chroot_mount()
{
    [[ -e "${DESTDIR}/sys" ]] || mkdir "${DESTDIR}/sys"
    [[ -e "${DESTDIR}/proc" ]] || mkdir "${DESTDIR}/proc"
    [[ -e "${DESTDIR}/dev" ]] || mkdir "${DESTDIR}/dev"
    mount -t sysfs sysfs "${DESTDIR}/sys"
    mount -t proc proc "${DESTDIR}/proc"
    mount -o bind /dev "${DESTDIR}/dev"
}

# chroot_umount()
# tears down chroot in target system
#
chroot_umount()
{
    umount "${DESTDIR}/proc"
    umount "${DESTDIR}/sys"
    umount "${DESTDIR}/dev"
}

getfstype()
{
    echo "$(${_BLKID} -p -i -s TYPE -o value ${1})"
}

# getfsuuid()
# converts /dev devices to FSUUIDs
#
# parameters: device file
# outputs:    FSUUID on success
#             nothing on failure
# returns:    nothing
getfsuuid()
{
    echo "$(${_BLKID} -p -i -s UUID -o value ${1})"
}

# parameters: device file
# outputs:    LABEL on success
#             nothing on failure
# returns:    nothing
getfslabel()
{
    echo "$(${_BLKID} -p -i -s LABEL -o value ${1})"
}

getpartuuid()
{
    echo "$(${_BLKID} -p -i -s PART_ENTRY_UUID -o value ${1})"
}

getpartlabel()
{
    echo "$(${_BLKID} -p -i -s PART_ENTRY_NAME -o value ${1})"
}

# activate_dmraid()
# activate dmraid devices
activate_dmraid()
{
    if [[ -e /sbin/dmraid ]]; then
        DIALOG --infobox "Activating dmraid arrays..." 0 0
        /sbin/dmraid -ay -I -Z >/dev/null 2>&1
    fi
}

# activate_lvm2
# activate lvm2 devices
activate_lvm2()
{
    ACTIVATE_LVM2=""
    if [[ -e /sbin/lvm ]]; then
        OLD_LVM2_GROUPS=${LVM2_GROUPS}
        OLD_LVM2_VOLUMES=${LVM2_VOLUMES}
        DIALOG --infobox "Scanning logical volumes..." 0 0
        /sbin/lvm vgscan --ignorelockingfailure >/dev/null 2>&1
        DIALOG --infobox "Activating logical volumes..." 0 0
        /sbin/lvm vgchange --ignorelockingfailure --ignoremonitoring -ay >/dev/null 2>&1
        LVM2_GROUPS="$(vgs -o vg_name --noheading 2>/dev/null)"
        LVM2_VOLUMES="$(lvs -o vg_name,lv_name --noheading --separator - 2>/dev/null)"
        [[ "${OLD_LVM2_GROUPS}" = "${LVM2_GROUPS}" && "${OLD_LVM2_GROUPS}" = "${LVM2_GROUPS}" ]] && ACTIVATE_LVM2="no"
    else
        ACTIVATE_LVM2="no"
    fi
}

# activate_raid
# activate md devices
activate_raid()
{
    ACTIVATE_RAID=""
    if [[ -e /sbin/mdadm ]]; then
        DIALOG --infobox "Activating RAID arrays..." 0 0
        /sbin/mdadm --assemble --scan >/dev/null 2>&1 || ACTIVATE_RAID="no"
    else
        ACTIVATE_RAID="no"
    fi
}

# activate_luks
# activate luks devices
activate_luks()
{
    ACTIVATE_LUKS=""
    if [[ -e /sbin/cryptsetup ]]; then
        DIALOG --infobox "Scanning for luks encrypted devices..." 0 0
        if [[ "$(${_BLKID} | grep "TYPE=\"crypto_LUKS\"")" ]]; then
            for PART in $(${_BLKID} | grep "TYPE=\"crypto_LUKS\"" | sed -e 's#:.*##g'); do
                # skip already encrypted devices, device mapper!
                OPEN_LUKS=""
                for devpath in $(ls /dev/mapper 2>/dev/null | grep -v control); do
                    [[ "$(cryptsetup status ${devpath} | grep ${PART})" ]] && OPEN_LUKS="no"
                done
                if ! [[ "${OPEN_LUKS}" = "no" ]]; then
                    RUN_LUKS=""
                    DIALOG --yesno "Setup detected luks encrypted device, do you want to activate ${PART} ?" 0 0 && RUN_LUKS="1"
                    [[ "${RUN_LUKS}" = "1" ]] && _enter_luks_name && _enter_luks_passphrase && _opening_luks
                    [[ "${RUN_LUKS}" = "" ]] && ACTIVATE_LUKS="no"
                else
                    ACTIVATE_LUKS="no"
                fi
            done
        else
            ACTIVATE_LUKS="no"
        fi
    else
        ACTIVATE_LUKS="no"
    fi
}

# activate_special_devices()
# activate special devices:
# activate dmraid, lvm2 and raid devices, if not already activated during bootup!
# run it more times if needed, it can be hidden by each other!
activate_special_devices()
{
    ACTIVATE_RAID=""
    ACTIVATE_LUKS=""
    ACTIVATE_LVM2=""
    activate_dmraid
    while ! [[ "${ACTIVATE_LVM2}" = "no" && "${ACTIVATE_RAID}" = "no"  && "${ACTIVATE_LUKS}" = "no" ]]; do
        activate_raid
        activate_lvm2
        activate_luks
    done
}

# destdir_mounts()
# check if PART_ROOT is set and if something is mounted on ${DESTDIR}
destdir_mounts(){
    # Don't ask for filesystem and create new filesystems
    ASK_MOUNTPOINTS=""
    PART_ROOT=""
    # check if something is mounted on ${DESTDIR}
    PART_ROOT="$(mount | grep "${DESTDIR} " | cut -d' ' -f 1)"
    # Run mountpoints, if nothing is mounted on ${DESTDIR}
    if [[ "${PART_ROOT}" = "" ]]; then
        DIALOG --msgbox "Setup couldn't detect mounted partition(s) in ${DESTDIR}, please set mountpoints first." 0 0
        mountpoints || return 1
    fi
}

# lists default linux blockdevices
default_blockdevices() {
    # ide devices
    for dev in $(ls ${block} 2>/dev/null | egrep '^hd'); do
        if [[ "$(cat ${block}/${dev}/device/media)" = "disk" ]]; then
            if ! [[ "$(cat ${block}/${dev}/size)" = "0" ]]; then
                if ! [[ "$(cat /proc/mdstat 2>/dev/null | grep "${dev}\[")" || "$(dmraid -rc | grep /dev/${dev})" ]]; then
                    echo "/dev/${dev}"
                    [[ "${1}" ]] && echo ${1}
                fi
            fi
        fi
    done
    #scsi/sata devices, and virtio blockdevices (/dev/vd*)
    for dev in $(ls ${block} 2>/dev/null | egrep '^[sv]d'); do
        # virtio device doesn't have type file!
        blktype="$(cat ${block}/${dev}/device/type 2>/dev/null)"
        if ! [[ "${blktype}" = "5" ]]; then
            if ! [[ "$(cat ${block}/${dev}/size)" = "0" ]]; then
                if ! [[ "$(cat /proc/mdstat 2>/dev/null | grep "${dev}\[")" || "$(dmraid -rc | grep /dev/${dev})" ]]; then
                    echo "/dev/${dev}"
                    [[ "${1}" ]] && echo ${1}
                fi
            fi
        fi
    done
}

# lists additional linux blockdevices
additional_blockdevices() {
    # Include additional controllers:
    # Mylex DAC960 PCI RAID controller, Compaq Next Generation Drive Array, 
    # Compaq Intelligent Drive Array
    for i in ${EXTRA_CONTROLLER}; do
        for dev in $(ls ${block} 2>/dev/null | egrep "^${i}"); do
            for k in $(ls ${block}/${dev} 2>/dev/null | egrep "${dev}*p"); do
                if [[ -d "${block}/${dev}/${k}" ]]; then
                    echo "/dev/${i}/$(echo ${dev} | sed -e 's#.*\!##g')"
                    [[ "${1}" ]] && echo ${1}
                    break
                fi
            done
        done
    done
    # Include MMC devices
    for dev in $(ls ${block} 2>/dev/null | egrep '^mmcblk'); do
        for i in $(ls ${block}/${dev} 2>/dev/null | egrep ${dev}p); do 
            if [[ -d "${block}/${dev}/${i}" ]]; then 
                echo "/dev/${dev}"
                [[ "${1}" ]] && echo ${1}
                break
            fi
        done
    done
}

# lists additional linux blockdevices partitions
additional_blockdevices_partitions() {
    # Mylex DAC960 PCI RAID controller, Compaq Next Generation Drive Array, 
    # Compaq Intelligent Drive Array
    for k in ${EXTRA_CONTROLLER}; do
        for dev in $(ls ${block} 2>/dev/null | egrep "^${k}"); do
            for i in $(ls ${block}/${dev} 2>/dev/null | egrep "${dev}*p"); do
                if [[ -d "${block}/${dev}/${i}" ]]; then
                    disk="${k}/$(echo ${dev} | sed -e 's#.*\!##g')"
                    part="${k}/$(echo ${i} | sed -e 's#.*\!##g')"
                    # exclude checks:
                    #- part of raid device
                    #  $(cat /proc/mdstat 2>/dev/null | grep ${part})
                    #- part of lvm2 device
                    #  $(${_BLKID} -p -i -o value -s TYPE /dev/${part} | grep "LVM2_member")
                    #- part of luks device
                    #  $(${_BLKID} -p -i -o value -s TYPE /dev/${part} | grep "crypto_LUKS")
                    #- extended partition on device
                    #  $(sfdisk -c /dev/${disk} $(echo ${part} | sed -e "s#${disk}\p##g" 2>/dev/null | grep "5")
                    #- bios_grub partitions
                    # $(echo ${part} | grep "[a-z]$(parted -s /dev/${disk} print 2>/dev/null | grep bios_grub | cut -d " " -f 2)$")
                    if ! [[ "$(cat /proc/mdstat 2>/dev/null | grep ${part})" || "$(${_BLKID} -p -i -o value -s TYPE /dev/${part} | grep "LVM2_member")" || "$(${_BLKID} -p -i -o value -s TYPE /dev/${part} | grep "crypto_LUKS")" || "$(sfdisk -c /dev/${disk} $(echo ${part} | sed -e "s#${disk}\p##g") 2>/dev/null | grep "5")" || "$(echo ${part} | grep "[a-z]$(parted -s /dev/${disk} print 2>/dev/null | grep bios_grub | cut -d " " -f 2)$")" ]]; then
                        echo "/dev/${part}"
                        [[ "${1}" ]] && echo ${1}
                    fi
                fi
            done
        done
    done
    # Include MMC devices
    for dev in $(ls ${block} 2>/dev/null | egrep '^mmcblk'); do
        for i in $(ls ${block}/${dev} 2>/dev/null | egrep ${dev}p); do 
            if [[ -d "${block}/${dev}/${i}" ]]; then
                # exclude checks:
                #- part of raid device
                #  $(cat /proc/mdstat 2>/dev/null | grep ${i})
                #- part of lvm2 device
                #  $(${_BLKID} -p -i -o value -s TYPE /dev/${i} | grep "LVM2_member")
                #- part of luks device
                #  $(${_BLKID} -p -i -o value -s TYPE /dev/${i} | grep "crypto_LUKS")
                #- extended partition on device
                #  $(sfdisk -c /dev/${dev} $(echo ${i} | sed -e "s#${dev}\p##g" 2>/dev/null | grep "5")
                #- bios_grub partitions
                # $(echo ${i} | grep "[a-z]$(parted -s /dev/${dev} print 2>/dev/null | grep bios_grub | cut -d " " -f 2)$")
                if ! [[ "$(cat /proc/mdstat 2>/dev/null | grep ${i})" || "$(${_BLKID} -p -i -o value -s TYPE /dev/${i} | grep "LVM2_member")" || $(${_BLKID} -p -i -o value -s TYPE /dev/${i} | grep "crypto_LUKS") || "$(sfdisk -c /dev/${dev} $(echo ${i} | sed -e "s#${dev}\p##g") 2>/dev/null | grep "5")" || "$(echo ${i} | grep "[a-z]$(parted -s /dev/${dev} print 2>/dev/null | grep bios_grub | cut -d " " -f 2)$")" ]]; then
                    echo "/dev/${i}"
                    [[ "${1}" ]] && echo ${1}
                fi
            fi
        done
    done
}

# list none partitionable raid md devices
raid_devices() {
    for devpath in $(ls ${block} 2>/dev/null | egrep '^md'); do
        if ! [[ "$(ls ${block}/${devpath} 2>/dev/null | egrep ${devpath}p)" ]]; then 
            # exlude md partitions which are part of lvm or luks
            if ! [[ "$(${_BLKID} -p -i /dev/${devpath} | grep "TYPE=\"LVM2_member\"")" || "$(${_BLKID} -p -i /dev/${devpath} | grep "TYPE=\"crypto_LUKS\"")" ]]; then
                    echo "/dev/${devpath}"
                    [[ "${1}" ]] && echo ${1}
            fi
        fi
    done
}

# lists default linux partitionable raid devices
partitionable_raid_devices() {
    for dev in $(ls ${block} 2>/dev/null | egrep '^md'); do
        for i in $(ls ${block}/${dev} 2>/dev/null | egrep "${dev}\!*p"); do 
            if [[ -d "${block}/${dev}/${i}" ]]; then 
                echo "/dev/${dev}"
                [[ "${1}" ]] && echo ${1}
                break
            fi
        done
    done
}

# lists default linux partitionable raid devices
partitionable_raid_devices_partitions() {
    for dev in $(ls ${block} 2>/dev/null | egrep '^md'); do
        for i in $(ls ${block}/${dev} 2>/dev/null | egrep ${dev}p); do 
            if [[ -d "${block}/${dev}/${i}" ]]; then
                # exlude md partitions which are part of lvm or luks
                if ! [[ "$(${_BLKID} -p -i /dev/${i} | grep "TYPE=\"LVM2_member\"")" || ! "$(${_BLKID} -p -i /dev/${i} | grep "TYPE=\"crypto_LUKS\"")" ]]; then
                    echo "/dev/${i}"
                    [[ "${1}" ]] && echo ${1}
                fi
            fi
        done
    done
}

# lists default linux dmraid devices
dmraid_devices() {
    if [[ -d /dev/mapper ]]; then
        for fakeraid in $(dmraid -s -c); do
                if [[ "$(echo ${fakeraid} | grep '_')" ]]; then
                    echo "/dev/mapper/${fakeraid}"
                    [[ "${1}" ]] && echo ${1}
                fi
        done
    fi
}

# check_dm_devices
# - remove part of encrypted devices
# - remove part of lvm
# - remove part ot raid
check_dm_devices() {
    for devpath in $(ls /dev/mapper 2>/dev/null | grep -v control); do
        k="$(${_BLKID} -p -i /dev/mapper/${devpath} 2>/dev/null | grep "TYPE=\"crypto_LUKS\"" | sed -e 's#:.*##g')"
        partofcrypt="${partofcrypt} ${k}"
    done
    for devpath in $(ls /dev/mapper 2>/dev/null | grep -v control); do
        k="$(${_BLKID} -p -i /dev/mapper/${devpath} 2>/dev/null | grep "TYPE=\"LVM2_member\"" | sed -e 's#:.*##g')"
        partoflvm="${partoflvm} ${k}"
    done
    for devpath in $(ls /dev/mapper 2>/dev/null | grep -v control); do
        k="$(${_BLKID} -p -i /dev/mapper/${devpath} 2>/dev/null | grep "TYPE=\"linux_raid_member\"" | sed -e 's#:.*##g')"
        partofraid="${partofraid} ${k}"
    done
}

# dm_devices
# - show device mapper devices 
dm_devices() {
    check_dm_devices
    for i in $(dmraid -s -c); do
        EXCLUDE_DMRAID=""
        if [[ "$(echo ${i} | grep '_')" ]]; then
             EXCLUDE_DMRAID="${EXCLUDE_DMRAID} -e ${i} "
        fi
    done
    if [[ -d /dev/mapper ]]; then
        for devpath in $(ls /dev/mapper 2>/dev/null | grep -v -e control ${EXCLUDE_DMRAID}); do
            if ! [[ "$(ls ${partofcrypt} 2>/dev/null | grep /dev/mapper/${devpath}$)" || "$(ls ${partoflvm} 2>/dev/null | grep /dev/mapper/${devpath}$)" || "$(ls ${partofraid} 2>/dev/null | grep /dev/mapper/${devpath}$)" ]]; then
                echo "/dev/mapper/${devpath}"
                [[ "${1}" ]] && echo ${1}
            fi
        done
    fi
}

# dmraid_partitions
# - show dmraid partitions
dmraid_partitions() {
    check_dm_devices
    if [[ -d /dev/mapper ]]; then
        for fakeraid in $(dmraid -s -c); do
            if [[ "$(echo ${fakeraid} | grep '_')" ]]; then
                for k in $(ls /dev/mapper/${fakeraid}*); do
                    devpath=$(basename ${k})
                    if ! [[ "$(dmraid -s -c | grep ${devpath}$)" || "$(ls ${partofcrypt} 2>/dev/null | grep /dev/mapper/${devpath}$)" || "$(ls ${partoflvm} 2>/dev/null | grep /dev/mapper/${devpath}$)" || "$(ls ${partofraid} 2>/dev/null | grep /dev/mapper/${devpath}$)" ]]; then
                        echo "/dev/mapper/${devpath}"
                        [[ "${1}" ]] && echo ${1}
                    fi
                done
            fi
        done
    fi
}

# do sanity checks on partitions, argument comes ${devpath} loop
default_partition_check() {
        disk=$(basename ${devpath})
        for part in $(ls ${block}/${disk} 2>/dev/null | egrep -v ^${disk}p | egrep ^${disk}); do
            # exclude checks:
            #- part of raid device
            #  $(cat /proc/mdstat 2>/dev/null | grep ${part})
            #- part of lvm2 device
            #  $(${_BLKID} -p -i -o value -s TYPE /dev/${part} | grep "LVM2_member")
            #- part of luks device
            #  $(${_BLKID} -p -i -o value -s TYPE /dev/${part} | grep "crypto_LUKS")
            #- extended partition
            #  $(sfdisk -c /dev/${disk} $(echo ${part} | sed -e "s#${disk}##g") 2>/dev/null | grep "5")
            #- extended partition on raid partition device and mmc device
            #  $(sfdisk -c /dev/${disk} $(echo ${part} | sed -e "s#${disk}\p##g" 2>/dev/null | grep "5")
            #- bios_grub partitions
            # $(echo ${part} | grep "[a-z]$(parted -s /dev/${disk} print 2>/dev/null | grep bios_grub | cut -d " " -f 2)$")
            if ! [[ "$(cat /proc/mdstat 2>/dev/null | grep ${part})" || "$(${_BLKID} -p -i -o value -s TYPE /dev/${part} | grep "LVM2_member")" || "$(${_BLKID} -p -i -o value -s TYPE /dev/${part} | grep "crypto_LUKS")" || "$(sfdisk -c /dev/${disk} $(echo ${part} | sed -e "s#${disk}##g") 2>/dev/null | grep "5")" || "$(sfdisk -c /dev/${disk} $(echo ${part} | sed -e "s#${disk}\p##g") 2>/dev/null | grep "5")" || "$(echo ${part} | grep "[a-z]$(parted -s /dev/${disk} print 2>/dev/null | grep bios_grub | cut -d " " -f 2)$")" ]]; then
                if [[ -d ${block}/${disk}/${part} ]]; then
                    echo "/dev/${part}"
                    [[ "${1}" ]] && echo ${1}
                fi
            fi
        done
}

finddisks() {
    default_blockdevices ${1}
    additional_blockdevices ${1}
    dmraid_devices ${1}
    partitionable_raid_devices ${1}
}

findpartitions() {
    for devpath in $(finddisks); do
        default_partition_check ${1}
    done
    additional_blockdevices_partitions ${1}
    dm_devices ${1}
    dmraid_partitions ${1}
    raid_devices ${1}
    partitionable_raid_devices_partitions ${1}
}

# don't check on raid devices!
findbootloaderdisks() {
    if ! [[ "${USE_DMRAID}" = "1" ]]; then
        default_blockdevices ${1}
        additional_blockdevices ${1}
    else
        dmraid_devices ${1}
    fi
}

# don't list raid devices, lvm2 and devicemapper!
findbootloaderpartitions() {
    if ! [[ "${USE_DMRAID}" = "1" ]]; then
        for devpath in $(findbootloaderdisks); do
            default_partition_check ${1}
        done
        additional_blockdevices_partitions ${1}
    else
        dmraid_partitions ${1}
    fi
}

# find any gpt/guid formatted disks
find_gpt() {
    GUID_DETECTED=""
    for i in $(finddisks); do
        [[ "$(${_BLKID} -p -i -o value -s PTTYPE ${i})" == "gpt" ]] && GUID_DETECTED="1"
    done
}

# freeze and unfreeze xfs, as hack for grub(2) installing
freeze_xfs() {
    sync
    if [[ -x /usr/sbin/xfs_freeze ]]; then
        if [[ "$(cat /proc/mounts | grep "${DESTDIR}/boot " | grep " xfs ")" ]]; then
            /usr/sbin/xfs_freeze -f ${DESTDIR}/boot >/dev/null 2>&1
            /usr/sbin/xfs_freeze -u ${DESTDIR}/boot >/dev/null 2>&1
        fi
        if [[ "$(cat /proc/mounts | grep "${DESTDIR} " | grep " xfs ")" ]]; then
            /usr/sbin/xfs_freeze -f ${DESTDIR} >/dev/null 2>&1
            /usr/sbin/xfs_freeze -u ${DESTDIR} >/dev/null 2>&1
        fi
    fi
}

mapdev() {
    partition_flag=0
    device_found=0
    # check if we use hd sd  or vd device
    if ! [[ "$(echo ${1} | grep /dev/sd)" || "$(echo ${1} | grep /dev/hd)" || "$(echo ${1} | grep /dev/vd)" ]]; then
        linuxdevice=$(echo ${1} | sed -e 's#p[0-9].*$##')
    else
        linuxdevice=$(echo ${1} | sed -e 's#[0-9].*$##g')
    fi
    if ! [[ "$(echo ${1} | grep /dev/sd)" || "$(echo ${1} | grep /dev/hd)" || "$(echo ${1} | grep /dev/vd)" ]]; then
        if [[ "$(echo ${1} | egrep 'p[0-9].*$')" ]]; then
            pnum=$(echo ${1} | sed -e 's#.*p##g')
            partition_flag=1
        fi
    else
        if [[ "$(echo ${1} | egrep '[0-9]$')" ]]; then
            # /dev/hdXY
            pnum=$(echo ${1} | cut -b9-)
            partition_flag=1
        fi
    fi
    for  dev in ${devs}; do
        if [[ "(" = $(echo ${dev} | cut -b1) ]]; then
            grubdevice="${dev}"
        else
            if [[ "${dev}" = "${linuxdevice}" ]]; then
                device_found=1
                break
            fi
        fi
    done
    if [[ "${device_found}" = "1" ]]; then
        if [[ "${partition_flag}" = "0" ]]; then
            echo "${grubdevice}"
        else
            grubdevice_stringlen=${#grubdevice}
            grubdevice_stringlen=$((${grubdevice_stringlen} - 1))
            grubdevice=$(echo ${grubdevice} | cut -b1-${grubdevice_stringlen})
            echo "${grubdevice},${pnum})"
        fi
    else
        echo "DEVICE NOT FOUND"
    fi
}

printk()
{
    case ${1} in
        "on")  echo 4 >/proc/sys/kernel/printk ;;
        "off") echo 0 >/proc/sys/kernel/printk ;;
    esac
}

# geteditor()
# prompts the user to choose an editor
# sets EDITOR global variable
#
geteditor() {
    if ! [[ "${EDITOR}" ]]; then
        DIALOG --menu "Select a Text Editor to Use" 10 35 3 \
        "1" "nano (easier)" \
        "2" "vi" 2>${ANSWER} || return 1
        case $(cat ${ANSWER}) in
            "1") EDITOR="nano" ;;
            "2") EDITOR="vi" ;;
        esac
    fi
}

# set device name scheme
set_device_name_scheme() {
    NAME_SCHEME_PARAMETER=""
    NAME_SCHEME_LEVELS=""
    MENU_DESC_TEXT=""
    
    # check if gpt/guid formatted disks are there
    find_gpt
    
    ## util-linux root=PARTUUID=/root=PARTLABEL= support - https://git.kernel.org/?p=utils/util-linux/util-linux.git;a=commitdiff;h=fc387ee14c6b8672761ae5e67ff639b5cae8f27c;hp=21d1fa53f16560dacba33fffb14ffc05d275c926
    ## mkinitcpio's init root=PARTUUID= support - https://projects.archlinux.org/mkinitcpio.git/tree/init_functions#n185
    
    if [[ "${GUID_DETECTED}" == "1" ]]; then
        NAME_SCHEME_LEVELS="${NAME_SCHEME_LEVELS} PARTUUID PARTUUID=<partuuid> PARTLABEL PARTLABEL=<partlabel>"
        MENU_DESC_TEXT="\nPARTUUID and PARTLABEL are specific to GPT disks.\nIn GPT disks, PARTUUID is recommended.\nIn MBR/msdos disks,"
    fi
    
    NAME_SCHEME_LEVELS="${NAME_SCHEME_LEVELS} FSUUID UUID=<uuid> FSLABEL LABEL=<label> KERNEL /dev/<kernelname>"
    DIALOG --menu "Select the device name scheme you want to use in config files. ${MENU_DESC_TEXT} FSUUID is recommended." 15 70 9 ${NAME_SCHEME_LEVELS} 2>${ANSWER} || return 1
    NAME_SCHEME_PARAMETER=$(cat ${ANSWER})
    NAME_SCHEME_PARAMETER_RUN="1"
}

# set GUID (gpt) usage
set_guid() {
    ## Lenovo BIOS-GPT issues - Arch Forum - https://bbs.archlinux.org/viewtopic.php?id=131149 , https://bbs.archlinux.org/viewtopic.php?id=133330 , https://bbs.archlinux.org/viewtopic.php?id=138958
    ## Lenovo BIOS-GPT issues - in Fedora - https://bugzilla.redhat.com/show_bug.cgi?id=735733, https://bugzilla.redhat.com/show_bug.cgi?id=749325 , http://git.fedorahosted.org/git/?p=anaconda.git;a=commit;h=ae74cebff312327ce2d9b5ac3be5dbe22e791f09
    GUIDPARAMETER=""
    DIALOG --defaultno --yesno "Do you want to use GUID Partition Table (GPT)?\n\nIt is a standard for the layout of the partition table on a physical hard disk. Although it forms a part of the Unified Extensible Firmware Interface (UEFI) standard (replacement for the PC BIOS firmware), it is also used on some BIOS systems because of the limitations of MBR aka msdos partition tables, which restrict maximum disk size to 2 TiB.\n\nWindows XP and earlier Windows systems cannot (without hacks) read or write to drives formatted with a GUID partition table, however, Vista and Windows 7 and later versions include the capability to use GPT for non-boot aka data disks (only UEFI systems can boot Windows from GPT disks).\n\nAttention:\n- Please check if your other operating systems have GPT support!\n- Use this option for a GRUB(2) setup, which should support LVM, RAID\n  etc., which doesn't fit into the usual 30k MS-DOS post-MBR gap.\n- BIOS-GPT boot may not work in some Lenovo systems (irrespective of the\n 
  bootloader used). " 0 0 && GUIDPARAMETER="yes"
}

# Get a list of available disks for use in the "Available disks" dialogs. This
# will print the mountpoints as follows, getting size info from /sys:
#   /dev/sda: 64000 MB
#   /dev/sdb: 64000 MB
_getavaildisks()
{
    for i in $(finddisks); do
            if [[ "$(echo "${i}" | grep '/dev/mapper')" ]]; then
                # device mapper is always 512 aligned!
                # only dmraid device can be here
                echo -n "${i} : "; echo $(($(expr 512 '*' $(dmsetup status ${i} | cut -f2 -d " "))/1000000)) MB; echo "\n"
            # special block devices
            elif [[  "$(echo "${i}" | grep "/dev/rd")" ]]; then
                echo -n "${i}: "; echo $(($(expr $(cat ${block}/rd\!$(basename ${i} | sed -e 's#p.*##g')/queue/logical_block_size) '*' $(cat ${block}/rd\!$(basename ${i} | sed -e 's#p.*##g')/size))/1000000)) MB; echo "\n"
            elif [[  "$(echo "${i}" | grep "/dev/cciss")" ]]; then
                echo -n "${i}: "; echo $(($(expr $(cat ${block}/cciss\!$(basename ${i} | sed -e 's#p.*##g')/queue/logical_block_size) '*' $(cat ${block}/cciss\!$(basename ${i} | sed -e 's#p.*##g')/size))/1000000)) MB; echo "\n"
            elif [[  "$(echo "${i}" | grep "/dev/ida")" ]]; then
                echo -n "${i}: "; echo $(($(expr $(cat ${block}/ida\!$(basename ${i} | sed -e 's#p.*##g')/queue/logical_block_size) '*' $(cat ${block}/ida\!$(basename ${i} | sed -e 's#p.*##g')/size))/1000000)) MB; echo "\n"
            else
                echo -n "${i} : "; echo $(($(expr $(cat ${block}/$(basename ${i})/queue/logical_block_size) '*' $(cat ${block}/$(basename ${i})/size))/1000000)) MB; echo "\n"
            fi
    done
}

# Get a list of available partitions for use in the "Available Mountpoints" dialogs. This
# will print the mountpoints as follows, getting size info from /sys:
#   /dev/sda1: 640 MB
#   /dev/sdb2: 640 MB
_getavailpartitions()
{
    for i in $(findpartitions); do
        # mmc and raid partitions
        if [[ "$(echo "${i}" | grep '/dev/md_d[0-9]')"  ||  "$(echo "${i}" | grep '/dev/md[0-9]p')" || "$(echo "${i}" | grep '/dev/mmcblk')" ]]; then
            echo -n "${i}: "; echo $(($(expr $(cat ${block}/$(basename ${i} | sed -e 's#p.*##g')/queue/logical_block_size) '*' $(cat ${block}/$(basename ${i} | sed -e 's#p.*##g')/$(basename ${i})/size))/1000000)) MB; echo "\n"
        # special block devices
        elif [[  "$(echo "${i}" | grep "/dev/rd")" ]]; then
                echo -n "${i}: "; echo $(($(expr $(cat ${block}/rd\!$(basename ${i} | sed -e 's#p.*##g')/queue/logical_block_size) '*' $(cat ${block}/rd\!$(basename ${i} | sed -e 's#p.*##g')/rd\!$(basename ${i})/size))/1000000)) MB; echo "\n"
        elif [[  "$(echo "${i}" | grep "/dev/cciss")" ]]; then
                echo -n "${i}: "; echo $(($(expr $(cat ${block}/cciss\!$(basename ${i} | sed -e 's#p.*##g')/queue/logical_block_size) '*' $(cat ${block}/cciss\!$(basename ${i} | sed -e 's#p.*##g')/cciss\!$(basename ${i})/size))/1000000)) MB; echo "\n"
        elif [[  "$(echo "${i}" | grep "/dev/ida")" ]]; then
                echo -n "${i}: "; echo $(($(expr $(cat ${block}/ida\!$(basename ${i} | sed -e 's#p.*##g')/queue/logical_block_size) '*' $(cat ${block}/ida\!$(basename ${i} | sed -e 's#p.*##g')/ida\!$(basename ${i})/size))/1000000)) MB; echo "\n"
        # raid device
        elif [[ "$(echo "${i}" | grep -v 'p' |grep '/dev/md')" ]]; then
            echo -n "${i}: "; echo $(($(expr $(cat ${block}/$(basename ${i})/queue/logical_block_size) '*' $(cat ${block}/$(basename ${i})/size))/1000000)) MB; echo "\n"
        # mapper devices
        elif [[ "$(echo "${i}" | grep '/dev/mapper')" ]]; then
            # mapper devices are always 512 aligned
            # crypt device
            if [[ "$(cryptsetup status ${i} 2>/dev/null)" ]]; then
                echo -n "${i}: "; echo $(($(expr 512 '*' $(cryptsetup status $(basename ${i}) | grep " size:" | sed -e 's#sectors##g' -e 's#size:##g'))/1000000)) MB; echo "\n"
            # dmraid device
            elif [[ "$(dmsetup info ${i} | grep 'DMRAID')"  ]]; then
                [[ "$(echo ${i} | grep 'p*[0-9]$')" ]] && echo -n "${i}: "; echo $(($(expr 512 '*' $(dmsetup status ${i} | cut -f2 -d " "))/1000000)) MB; echo "\n"
            # mapper device
            else
                echo -n "${i}: "; echo $(lvs -o lv_size --noheading --units m ${i} | sed -e 's#m##g') MB; echo "\n"
            fi
        else
            echo -n "${i}: "; echo $(($(expr $(cat ${block}/$(basename ${i} | sed -e 's#[0-9].*##g')/queue/logical_block_size) '*' $(cat ${block}/$(basename ${i} | sed -e 's#[0-9].*##g')/$(basename ${i})/size))/1000000)) MB; echo "\n"
        fi
    done
}

# Disable swap and all mounted partitions for the destination system. Unmount
# the destination root partition last!
_umountall()
{
    DIALOG --infobox "Disabling swapspace, unmounting already mounted disk devices..." 0 0
    swapoff -a >/dev/null 2>&1
    for i in $(findmnt --list --submounts ${DESTDIR} -o TARGET -n | tac); do
        umount $i
    done
}

# Disable all software raid devices
_stopmd()
{
    if [[ "$(cat /proc/mdstat 2>/dev/null | grep ^md)" ]]; then
        DISABLEMD=""
        DIALOG --defaultno --yesno "Setup detected already running raid devices, do you want to disable them completely?" 0 0 && DISABLEMD="1"
        if [[ "${DISABLEMD}" = "1" ]]; then
            DIALOG --infobox "Disabling all software raid devices..." 0 0
            for i in $(cat /proc/mdstat 2>/dev/null | grep ^md | sed -e 's# :.*##g'); do
                mdadm --manage --stop /dev/${i} > ${LOG}
            done
            DIALOG --infobox "Cleaning superblocks of all software raid devices..." 0 0
            for i in $(${_BLKID} | grep "TYPE=\"linux_raid_member\"" | sed -e 's#:.*##g'); do
                mdadm --zero-superblock ${i} > ${LOG}
            done
        fi
    fi
    DISABLEMDSB=""
    if [[ "$(${_BLKID} | grep "TYPE=\"linux_raid_member\"")" ]]; then
        DIALOG --defaultno --yesno "Setup detected superblock of raid devices, do you want to clean the superblock of them?" 0 0 && DISABLEMDSB="1"
        if [[ "${DISABLEMDSB}" = "1" ]]; then
            DIALOG --infobox "Cleaning superblocks of all software raid devices..." 0 0
            for i in $(${_BLKID} | grep "TYPE=\"linux_raid_member\"" | sed -e 's#:.*##g'); do
                mdadm --zero-superblock ${i} > ${LOG}
            done
        fi
    fi
}

# Disable all lvm devices
_stoplvm()
{
    DISABLELVM=""
    DETECTED_LVM=""
    LV_VOLUMES="$(lvs -o vg_name,lv_name --noheading --separator - 2>/dev/null)"
    LV_GROUPS="$(vgs -o vg_name --noheading 2>/dev/null)"
    LV_PHYSICAL="$(pvs -o pv_name --noheading 2>/dev/null)"
    ! [[ "${LV_VOLUMES}" = "" ]] && DETECTED_LVM=1
    ! [[ "${LV_GROUPS}" = "" ]] && DETECTED_LVM=1
    ! [[ "${LV_PHYSICAL}" = "" ]] && DETECTED_LVM=1
    if [[ "${DETECTED_LVM}" = "1" ]]; then
        DIALOG --defaultno --yesno "Setup detected lvm volumes, volume groups or physical devices, do you want to remove them completely?" 0 0 && DISABLELVM="1"
    fi
    if [[ "${DISABLELVM}" = "1" ]]; then
        DIALOG --infobox "Removing logical volumes ..." 0 0
        for i in ${LV_VOLUMES}; do
            lvremove -f /dev/mapper/${i} 2>/dev/null> ${LOG}
        done
        DIALOG --infobox "Removing logical groups ..." 0 0
        for i in ${LV_GROUPS}; do
            vgremove -f ${i} 2>/dev/null > ${LOG}
        done
        DIALOG --infobox "Removing physical volumes ..." 0 0
        for i in ${LV_PHYSICAL}; do
            pvremove -f ${i} 2>/dev/null > ${LOG}
        done
    fi
}

# Disable all luks encrypted devices
_stopluks()
{
    DISABLELUKS=""
    DETECTED_LUKS=""
    LUKSDEVICE=""

    # detect already running luks devices
    LUKS_DEVICES="$(ls /dev/mapper/ | grep -v control)"
    for i in ${LUKS_DEVICES}; do
        cryptsetup status ${i} 2>/dev/null && LUKSDEVICE="${LUKSDEVICE} ${i}"
    done
    ! [[ "${LUKSDEVICE}" = "" ]] && DETECTED_LUKS=1
    if [[ "${DETECTED_LUKS}" = "1" ]]; then
        DIALOG --defaultno --yesno "Setup detected running luks encrypted devices, do you want to remove them completely?" 0 0 && DISABLELUKS="1"
    fi
    if [[ "${DISABLELUKS}" = "1" ]]; then
        DIALOG --infobox "Removing luks encrypted devices ..." 0 0
        for i in ${LUKSDEVICE}; do
            LUKS_REAL_DEVICE="$(echo $(cryptsetup status ${i} | grep device: | sed -e 's#device:##g'))"
            cryptsetup remove ${i} > ${LOG}
            # delete header from device
            dd if=/dev/zero of=${LUKS_REAL_DEVICE} bs=512 count=2048 >/dev/null 2>&1
        done
    fi
    
    DISABLELUKS=""
    DETECTED_LUKS=""

    # detect not running luks devices
    [[ "$(${_BLKID} | grep "TYPE=\"crypto_LUKS\"")" ]] && DETECTED_LUKS=1
    if [[ "${DETECTED_LUKS}" = "1" ]]; then
        DIALOG --defaultno --yesno "Setup detected not running luks encrypted devices, do you want to remove them completely?" 0 0 && DISABLELUKS="1"
    fi
    if [[ "${DISABLELUKS}" = "1" ]]; then
        DIALOG --infobox "Removing not running luks encrypted devices ..." 0 0
        for i in $(${_BLKID} | grep "TYPE=\"crypto_LUKS\"" | sed -e 's#:.*##g'); do
            # delete header from device
            dd if=/dev/zero of=${i} bs=512 count=2048 >/dev/null 2>&1
        done
    fi
    [[ -e /tmp/.crypttab ]] && rm /tmp/.crypttab
}

#_dmraid_update
_dmraid_update()
{
    DIALOG --infobox "Deactivating dmraid devices ..." 0 0
    dmraid -an >/dev/null 2>&1
    if [[ "${DETECTED_LVM}" = "1" || "${DETECTED_LUKS}" = "1" ]]; then
        DIALOG --defaultno --yesno "Setup detected running dmraid devices and/or running lvm2, luks encrypted devices. If you reduced/deleted partitions on your dmraid device a complete reset of devicemapper devices is needed. This will reset also your created lvm2 or encrypted devices. Are you sure you want to do this?" 0 0 && RESETDM="1"
        if [[ "${RESETDM}" = "1" ]]; then
            DIALOG --infobox "Resetting devicemapper devices ..." 0 0
            dmsetup remove_all >/dev/null 2>&1
        fi
    else
        DIALOG --infobox "Resetting devicemapper devices ..." 0 0
        dmsetup remove_all >/dev/null 2>&1
    fi
    DIALOG --infobox "Reactivating dmraid devices ..." 0 0
    dmraid -ay -Z >/dev/null 2>&1
}

#helpbox for raid
_helpraid()
{
DIALOG --msgbox "LINUX SOFTWARE RAID SUMMARY:\n
-----------------------------\n\n
Linear mode:\n
You have two or more partitions which are not necessarily the same size\n
(but of course can be), which you want to append to each other.\n
Spare-disks are not supported here. If a disk dies, the array dies with\n
it.\n\n
RAID-0:\n
You have two or more devices, of approximately the same size, and you want\n
to combine their storage capacity and also combine their performance by\n
accessing them in parallel. Like in Linear mode, spare disks are not\n
supported here either. RAID-0 has no redundancy, so when a disk dies, the\n
array goes with it.\n\n
RAID-1:\n
You have two devices of approximately same size, and you want the two to\n
be mirrors of each other. Eventually you have more devices, which you\n
want to keep as stand-by spare-disks, that will automatically become a\n
part of the mirror if one of the active devices break.\n\n
RAID-4:\n
You have three or more devices of roughly the same size and you want\n
a way that protects data against loss of any one disk.\n
Fault tolerance is achieved by adding an extra disk to the array, which\n
is dedicated to storing parity information. The overall capacity of the\n
array is reduced by one disk.\n
The storage efficiency is 66 percent. With six drives, the storage\n
efficiency is 87 percent. The main disadvantage is poor performance for\n
multiple,\ simultaneous, and independent read/write operations.\n
Thus, if any disk fails, all data stay intact. But if two disks fail,\n
all data is lost.\n\n
RAID-5:\n
You have three or more devices of roughly the same size, you want to\n
combine them into a larger device, but still to maintain a degree of\n
redundancy fordata safety. Eventually you have a number of devices to use\n
as spare-disks, that will not take part in the array before another device\n
fails. If you use N devices where the smallest has size S, the size of the\n
entire array will be (N-1)*S. This \"missing\" space is used for parity\n
(redundancy) information. Thus, if any disk fails, all data stay intact.\n
But if two disks fail, all data is lost.\n\n
RAID-6:\n
You have four or more devices of roughly the same size and you want\n
a way that protects data against loss of any two disks.\n
Fault tolerance is achieved by adding an two extra disk to the array,\n
which is dedicated to storing parity information. The overall capacity\n
of the array is reduced by 2 disks.\n
Thus, if any two disks fail, all data stay intact. But if 3 disks fail,\n
all data is lost.\n\n
RAID-10:\n
Shorthand for RAID1+0, a mirrored striped array and needs a minimum of\n
two disks. It provides superior data security and can survive multiple\n
disk failures. The main disadvantage is cost, because 50% of your\n
storage is duplication." 0 0
}

# Create raid or raid_partition
_raid()
{
    MDFINISH=""
    while [[ "${MDFINISH}" != "DONE" ]]; do
        activate_special_devices
        : >/tmp/.raid
        : >/tmp/.raid-spare
        # check for devices
        PARTS="$(findpartitions _)"
        ALREADYINUSE=""
        #hell yeah, this is complicated! kill software raid devices already in use.
        ALREADYINUSE=$(cat /proc/mdstat 2>/dev/null | grep ^md | sed -e 's# :.*linear##g' -e 's# :.*raid[0-9][0-9]##g' -e 's# :.*raid[0-9]##g' -e 's#\[[0-9]\]##g')
        for i in ${ALREADYINUSE}; do
            PARTS=$(echo ${PARTS} | sed -e "s#/dev/${i}\ _##g" -e "s#/dev/${i}\p[0-9]\ _##g")
            k=$(echo /dev/${i} | sed -e 's#[0-9]##g')
            if ! [[ "$(echo ${k} | grep ^md)" ]]; then
                PARTS=$(echo ${PARTS} | sed -e "s#${k}\ _##g")
            fi
        done
        # skip encrypted mapper devices which contain raid devices
        ALREADYINUSE=""
        for i in $(ls /dev/mapper/* 2>/dev/null | grep -v control); do
            cryptsetup status ${i} 2>/dev/null | grep -q "device:.*/dev/md" && ALREADYINUSE="${ALREADYINUSE} ${i}"
        done
        # skip lvm with raid devices
        for devpath in $(pvs -o pv_name --noheading); do
            # skip simple lvm device with raid device
            if [[ "$(echo ${devpath} | grep /dev/md)" ]]; then
                killvolumegroup="$(echo $(pvs -o vg_name --noheading ${devpath}))"
                ALREADYINUSE="${ALREADYINUSE} $(ls /dev/mapper/${killvolumegroup}-*)"
            fi
            # skip encrypted raid device
            if [[ "$(echo ${devpath} | grep dm-)" ]]; then
                if [[ "$(cryptsetup status $(basename ${devpath}) | grep "device:.*/dev/md")" ]]; then
                   killvolumegroup="$(echo $(pvs -o vg_name --noheading ${devpath}))"
                   ALREADYINUSE="${ALREADYINUSE} $(ls /dev/mapper/${killvolumegroup}-*)"
                fi
            fi
        done
        # skip already encrypted volume devices with raid device
        for devpath in $(ls /dev/mapper/ 2>/dev/null | grep -v control); do
            realdevice="$(cryptsetup status ${devpath} 2>/dev/null | grep "device:.*/dev/mapper/" | sed -e 's#.*\ ##g')"
            if [[ "$(lvs ${realdevice} 2>/dev/null)" ]]; then
                vg="$(echo $(lvs -o vg_name --noheading ${realdevice}))"
                if [[ "$(pvs -o pv_name,vg_name --noheading | grep "${vg}$" | grep "/dev/md")" ]]; then
                   ALREADYINUSE="${ALREADYINUSE} /dev/mapper/${devpath}"
                fi
            fi
        done
        for i in ${ALREADYINUSE}; do
            PARTS=$(echo ${PARTS} | sed -e "s#${i}\ _##g")
        done
        # break if all devices are in use
        if [[ "${PARTS}" = "" ]]; then
            DIALOG --msgbox "All devices in use. No more devices left for new creation." 0 0
            return 1
        fi
        # enter raid device name
        RAIDDEVICE=""
        while [[ "${RAIDDEVICE}" = "" ]]; do
            if [[ "${RAID_PARTITION}" = "" ]]; then
                DIALOG --inputbox "Enter the node name for the raiddevice:\n/dev/md[number]\n/dev/md0\n/dev/md1\n\n" 15 65 "/dev/md0" 2>${ANSWER} || return 1
            fi
            if [[ "${RAID_PARTITION}" = "1" ]]; then
                DIALOG --inputbox "Enter the node name for partitionable raiddevice:\n/dev/md_d[number]\n/dev/md_d0\n/dev/md_d1" 15 65 "/dev/md_d0" 2>${ANSWER} || return 1
            fi
            RAIDDEVICE=$(cat ${ANSWER})
            if [[ "$(cat /proc/mdstat 2>/dev/null | grep "^$(echo ${RAIDDEVICE} | sed -e 's#/dev/##g')")" ]]; then
                DIALOG --msgbox "ERROR: You have defined 2 identical node names! Please enter another name." 8 65
                RAIDDEVICE=""
            fi
        done
        RAIDLEVELS="linear - raid0 - raid1 - raid4 - raid5 - raid6 - raid10 -"
        DIALOG --menu "Select the raid level you want to use" 21 50 11 ${RAIDLEVELS} 2>${ANSWER} || return 1
        LEVEL=$(cat ${ANSWER})
        # raid5 and raid10 support parity parameter
        PARITY=""
        if [[ "${LEVEL}" = "raid5" || "${LEVEL}" = "raid6" || "${LEVEL}" = "raid10" ]]; then
            PARITYLEVELS="left-asymmetric - left-symmetric - right-asymmetric - right-symmetric -"
            DIALOG --menu "Select the parity layout you want to use (default is left-symmetric)" 21 50 13 ${PARITYLEVELS} 2>${ANSWER} || return 1
            PARTIY=$(cat ${ANSWER})
        fi
        # show all devices with sizes
        DIALOG --msgbox "DISKS:\n$(_getavaildisks)\n\nPARTITIONS:\n$(_getavailpartitions)" 0 0
        # select the first device to use, no missing option available!
        RAIDNUMBER=1
        DIALOG --menu "Select device ${RAIDNUMBER}" 21 50 13 ${PARTS} 2>${ANSWER} || return 1
        PART=$(cat ${ANSWER})
        echo "${PART}" >>/tmp/.raid
        while [[ "${PART}" != "DONE" ]]; do
            RAIDNUMBER=$((${RAIDNUMBER} + 1))
            # clean loop from used partition and options
            PARTS="$(echo ${PARTS} | sed -e "s#${PART}\ _##g" -e 's#MISSING\ _##g' -e 's#SPARE\ _##g')"
            # raid0 doesn't support missing devices
            ! [[ "${LEVEL}" = "raid0" || "${LEVEL}" = "linear" ]] && MDEXTRA="MISSING _"
            # add more devices
            DIALOG --menu "Select additional device ${RAIDNUMBER}" 21 50 13 ${PARTS} ${MDEXTRA} DONE _ 2>${ANSWER} || return 1
            PART=$(cat ${ANSWER})
            SPARE=""
            ! [[ "${LEVEL}" = "raid0" || "${LEVEL}" = "linear" ]] && DIALOG --yesno --defaultno "Would you like to use ${PART} as spare device?" 0 0 && SPARE="1"
            [[ "${PART}" = "DONE" ]] && break
            if [[ "${PART}" = "MISSING" ]]; then
                DIALOG --yesno "Would you like to create a degraded raid on ${RAIDDEVICE}?" 0 0 && DEGRADED="missing"
                echo "${DEGRADED}" >>/tmp/.raid
            else
                if [[ "${SPARE}" = "1" ]]; then
                    echo "${PART}" >>/tmp/.raid-spare
                else
                    echo "${PART}" >>/tmp/.raid
                fi
            fi
        done
        # final step ask if everything is ok?
        DIALOG --yesno "Would you like to create ${RAIDDEVICE} like this?\n\nLEVEL:\n${LEVEL}\n\nDEVICES:\n$(for i in $(cat /tmp/.raid); do echo "${i}\n";done)\nSPARES:\n$(for i in $(cat /tmp/.raid-spare); do echo "${i}\n";done)" 0 0 && MDFINISH="DONE"
    done
    _createraid
}

# create raid device
_createraid()
{
    DEVICES="$(echo -n $(cat /tmp/.raid))"
    SPARES="$(echo -n $(cat /tmp/.raid-spare))"
    # combine both if spares are available, spares at the end!
    [[ -n ${SPARES} ]] && DEVICES="${DEVICES} ${SPARES}"
    # get number of devices
    RAID_DEVICES="$(cat /tmp/.raid | wc -l)"
    SPARE_DEVICES="$(cat /tmp/.raid-spare | wc -l)"
    # generate options for mdadm
    RAIDOPTIONS="--force --run --level=${LEVEL}"
    [[ "$(echo ${RAIDDEVICE} | grep /md_d[0-9])" ]] && RAIDOPTIONS="${RAIDOPTIONS} -a mdp"
    ! [[ "${RAID_DEVICES}" = "0" ]] && RAIDOPTIONS="${RAIDOPTIONS} --raid-devices=${RAID_DEVICES}"
    ! [[ "${SPARE_DEVICES}" = "0" ]] && RAIDOPTIONS="${RAIDOPTIONS} --spare-devices=${SPARE_DEVICES}"
    ! [[ "${PARITY}" = "" ]] && RAIDOPTIONS="${RAIDOPTIONS} --layout=${PARITY}"
    DIALOG --infobox "Creating ${RAIDDEVICE}..." 0 0
    mdadm --create ${RAIDDEVICE} ${RAIDOPTIONS} ${DEVICES} >${LOG} 2>&1
    if [[ $? -gt 0 ]]; then
        DIALOG --msgbox "Error creating ${RAIDDEVICE} (see ${LOG} for details)." 0 0
        return 1
    fi
    if [[ "$(echo ${RAIDDEVICE} | grep /md_d[0-9])" ]]; then
        # switch for mbr usage
        set_guid
        if [[ "${GUIDPARAMETER}" = "" ]]; then
            DIALOG --msgbox "Now you'll be put into the parted program where you can partition your raiddevice to your needs." 18 70
            clear
            parted ${RAIDDEVICE} print
            parted ${RAIDDEVICE}
        else
            DISC=${RAIDDEVICE}
            RUN_CGDISK="1"
            CHECK_BIOS_BOOT_GRUB=""
            CHECK_UEFISYS_PART=""
            check_gpt
        fi
    fi
}

# help for lvm
_helplvm()
{
DIALOG --msgbox "LOGICAL VOLUME SUMMARY:\n
-----------------------------\n\n
LVM is a Logical Volume Manager for the Linux kernel. With LVM you can\n
abstract your storage space and have \"virtual partitions\" which are easier\n
to modify.\n\nThe basic building block of LVM are:\n
- Physical volume (PV):\n
  Partition on hard disk (or even hard disk itself or loopback file) on\n
  which you can have virtual groups. It has a special header and is\n
  divided into physical extents. Think of physical volumes as big building\n
  blocks which can be used to build your hard drive.\n
- Volume group (VG):\n 
  Group of physical volumes that are used as storage volume (as one disk).\n
  They contain logical volumes. Think of volume groups as hard drives.\n 
- Logical volume(LV):\n
  A \"virtual/logical partition\" that resides in a volume group and is\n 
  composed of physical extents. Think of logical volumes as normal\n
  partitions." 0 0
}

# Creates physical volume
_createpv()
{
    PVFINISH=""
    while [[ "${PVFINISH}" != "DONE" ]]; do
        activate_special_devices
        : >/tmp/.pvs-create
        PVDEVICE=""
        PARTS="$(findpartitions _)"
        ALREADYINUSE=""
        # skip volume devices
        for i in $(ls /dev/mapper/* | grep -v control); do
            [[ "$(lvs ${i} 2>/dev/null)" ]] && ALREADYINUSE="${ALREADYINUSE} ${i}"
        done
        # skip already encrypted volume devices
        for devpath in $(ls /dev/mapper/ 2>/dev/null | grep -v control); do
            realdevice="$(cryptsetup status ${devpath} 2>/dev/null | grep "device:.*/dev/mapper/" | sed -e 's#.*\ ##g')"
            if ! [[ "${realdevice}" = "" ]]; then
                [[ "$(lvs ${realdevice} 2>/dev/null)" ]] && ALREADYINUSE="${ALREADYINUSE} /dev/mapper/${devpath}"
            fi
        done
        # skip md devices, which already have lvm devices!
        for i in ${PARTS}; do
            mdcheck="$(echo ${i} | sed -e 's#/dev/##g')"
            if ! [[ "$(find ${block}/${mdcheck}/slaves/ -name 'dm*' 2>/dev/null)" = "" ]]; then
                for k in $(find ${block}/${mdcheck}/slaves/ -name 'dm*' 2>/dev/null); do
                    # check encrypted volume
                    realdevice="$(cryptsetup status $(cat ${k}/dm/name) 2>/dev/null | grep "device:.*/dev/mapper/" | sed -e 's#.*\ ##g')"
                    [[ "$(lvs ${realdevice} 2>/dev/null)" ]] && ALREADYINUSE="${ALREADYINUSE} ${i}"
                    # check on normal lvs
                    [[ "$(lvs /dev/mapper/$(cat ${k}/dm/name) 2>/dev/null)" ]] && ALREADYINUSE="${ALREADYINUSE} ${i}"
                done
            fi
        done
        # skip md partition devices, which already have lvm devices!
        for i in ${PARTS}; do
            mdcheck="$(echo ${i} | grep /dev/md*p | sed -e 's#p.*##g' -e 's#/dev/##g')"
            if [[ "$(find ${block}/${mdcheck}/slaves/ -name 'dm*' 2>/dev/null)" != "" && "${mdcheck}" != "" ]]; then
                for k in $(find ${block}/${mdcheck}/slaves/ -name 'dm*' 2>/dev/null); do
                    # check encrypted volume
                    realdevice="$(cryptsetup status $(cat ${k}/dm/name) 2>/dev/null | grep "device:.*/dev/mapper/" | sed -e 's#.*\ ##g')"
                    [[ "$(lvs ${realdevice} 2>/dev/null)" ]] && ALREADYINUSE="${ALREADYINUSE} ${i}"
                   # check on normal lvs
                    [[ "$(lvs /dev/mapper/$(cat ${k}/dm/name) 2>/dev/null)" ]] && ALREADYINUSE="${ALREADYINUSE} ${i}"
                done
            fi
        done
        for i in ${ALREADYINUSE}; do
            PARTS=$(echo ${PARTS} | sed -e "s#${i}\ _##g")
        done
        # break if all devices are in use
        if [[ "${PARTS}" = "" ]]; then
            DIALOG --msgbox "No devices left for physical volume creation." 0 0
            return 1
        fi
        # show all devices with sizes
        DIALOG --msgbox "DISKS:\n$(_getavaildisks)\n\nPARTITIONS:\n$(_getavailpartitions)\n\n" 0 0
        # select the first device to use
        DEVNUMBER=1
        DIALOG --menu "Select device number ${DEVNUMBER} for physical volume" 21 50 13 ${PARTS} 2>${ANSWER} || return 1
        PART=$(cat ${ANSWER})
        echo "${PART}" >>/tmp/.pvs-create
        while [[ "${PART}" != "DONE" ]]; do
            DEVNUMBER=$((${DEVNUMBER} + 1))
            # clean loop from used partition and options
            PARTS="$(echo ${PARTS} | sed -e "s#${PART}\ _##g")"
            # add more devices
            DIALOG --menu "Select additional device number ${DEVNUMBER} for physical volume" 21 50 13 ${PARTS} DONE _ 2>${ANSWER} || return 1
            PART=$(cat ${ANSWER})
            [[ "${PART}" = "DONE" ]] && break
            echo "${PART}" >>/tmp/.pvs-create
        done
        # final step ask if everything is ok?
        DIALOG --yesno "Would you like to create physical volume on devices below?\n$(cat /tmp/.pvs-create | sed -e 's#$#\\n#g')" 0 0 && PVFINISH="DONE"
    done
    DIALOG --infobox "Creating physical volume on ${PART}..." 0 0
    PART="$(echo -n $(cat /tmp/.pvs-create))"
    pvcreate ${PART} >${LOG} 2>&1
    if [[ $? -gt 0 ]]; then
        DIALOG --msgbox "Error creating physical volume on ${PART} (see ${LOG} for details)." 0 0
        return 1
    fi
}

#find physical volumes that are not in use
findpv()
{
    for i in $(pvs -o pv_name --noheading);do
        if [[ "$(pvs -o vg_name --noheading ${i})" = "      " ]]; then
                if [[ "$(echo ${i} | grep /dev/dm-)" ]]; then
                    for k in $(ls /dev/mapper | grep -v control); do
                        if [[ -h /dev/mapper/${k} ]]; then
                            pv="$(basename ${i})"
                            if [[ "$(readlink /dev/mapper/${k} | grep ${pv}$)" ]]; then
                                echo "${i}" | sed -e "s#/dev/dm-.*#/dev/mapper/${k}#g"
                                [[ "${1}" ]] && echo ${1}
                            fi
                        fi
                    done
                else
                    echo "${i}"
                    [[ "${1}" ]] && echo ${1}
                fi
        fi
    done
}

getavailablepv()
{
    for i in "$(pvs -o pv_name,pv_size --noheading --units m)"; do
            if [[ "$(echo ${i} | grep /dev/dm-)" ]]; then
                for k in $(ls /dev/mapper | grep -v control); do
                    if [[ -h /dev/mapper/${k} ]]; then
                        pv="$(basename ${i})"
                        if [[ "$(readlink /dev/mapper/${k} | grep ${pv}$)" ]]; then
                            echo "${i}" | sed -e "s#/dev/dm-.* #/dev/mapper/${k} #g" | sed -e 's#$#\\n#'
                        fi
                    fi
                 done
            else
                echo "${i}" | sed -e 's#$#\\n#'
            fi
    done
}

#find volume groups that are not already full in use
findvg()
{
    for dev in $(vgs -o vg_name --noheading);do
        if ! [[ "$(vgs -o vg_free --noheading --units m ${dev} | grep " 0m$")" ]]; then
            echo "${dev}"
            [[ "${1}" ]] && echo ${1}
        fi
    done
}

getavailablevg()
{
    for i in $(vgs -o vg_name,vg_free --noheading --units m); do
        if ! [[ "$(echo ${i} | grep " 0m$")" ]]; then
            echo ${i} | sed -e 's#$#\\n#'
        fi
    done
}

# Creates volume group
_createvg()
{
    VGFINISH=""
    while [[ "${VGFINISH}" != "DONE" ]]; do
        : >/tmp/.pvs
        VGDEVICE=""
        PVS=$(findpv _)
        # break if all devices are in use
        if [[ "${PVS}" = "" ]]; then
            DIALOG --msgbox "No devices left for Volume Group creation." 0 0
            return 1
        fi
        # enter volume group name
        VGDEVICE=""
        while [[ "${VGDEVICE}" = "" ]]; do
            DIALOG --inputbox "Enter the Volume Group name:\nfoogroup\n<yourvolumegroupname>\n\n" 15 65 "foogroup" 2>${ANSWER} || return 1
            VGDEVICE=$(cat ${ANSWER})
            if [[ "$(vgs -o vg_name --noheading 2>/dev/null | grep "^  $(echo ${VGDEVICE})")" ]]; then
                DIALOG --msgbox "ERROR: You have defined 2 identical Volume Group names! Please enter another name." 8 65
                VGDEVICE=""
            fi
        done
        # show all devices with sizes
        DIALOG --msgbox "Physical Volumes:\n$(getavailablepv)\n\nPhysical Volumes that are not shown in next dialog, are already in use!" 0 0
        # select the first device to use, no missing option available!
        PVNUMBER=1
        DIALOG --menu "Select Physical Volume ${PVNUMBER} for ${VGDEVICE}" 21 50 13 ${PVS} 2>${ANSWER} || return 1
        PV=$(cat ${ANSWER})
        echo "${PV}" >>/tmp/.pvs
        while [[ "${PVS}" != "DONE" ]]; do
            PVNUMBER=$((${PVNUMBER} + 1))
            # clean loop from used partition and options
            PVS="$(echo ${PVS} | sed -e "s#${PV}\ _##g")"
            # add more devices
            DIALOG --menu "Select additional Physical Volume ${PVNUMBER} for ${VGDEVICE}" 21 50 13 ${PVS} DONE _ 2>${ANSWER} || return 1
            PV=$(cat ${ANSWER})
            [[ "${PV}" = "DONE" ]] && break
            echo "${PV}" >>/tmp/.pvs
        done
        # final step ask if everything is ok?
        DIALOG --yesno "Would you like to create Volume Group like this?\n\n${VGDEVICE}\n\nPhysical Volumes:\n$(cat /tmp/.pvs | sed -e 's#$#\\n#g')" 0 0 && VGFINISH="DONE"
    done
    DIALOG --infobox "Creating Volume Group ${VGDEVICE}..." 0 0
    PV="$(echo -n $(cat /tmp/.pvs))"
    vgcreate ${VGDEVICE} ${PV} >${LOG} 2>&1
    if [[ $? -gt 0 ]]; then
        DIALOG --msgbox "Error creating Volume Group ${VGDEVICE} (see ${LOG} for details)." 0 0
        return 1
    fi
}

# Creates logical volume
_createlv()
{
    LVFINISH=""
    while [[ "${LVFINISH}" != "DONE" ]]; do
        LVDEVICE=""
        LV_SIZE_SET=""
        LVS=$(findvg _)
        # break if all devices are in use
        if [[ "${LVS}" = "" ]]; then
            DIALOG --msgbox "No Volume Groups with free space available for Logical Volume creation." 0 0
            return 1
        fi
        # show all devices with sizes
        DIALOG --msgbox "Volume Groups:\n$(getavailablevg)\n\nVolume Groups that are not shown, are already 100% in use!" 0 0
        DIALOG --menu "Select Volume Group" 21 50 13 ${LVS} 2>${ANSWER} || return 1
        LV=$(cat ${ANSWER})
        # enter logical volume name
        LVDEVICE=""
        while [[ "${LVDEVICE}" = "" ]]; do
            DIALOG --inputbox "Enter the Logical Volume name:\nfooname\n<yourvolumename>\n\n" 15 65 "fooname" 2>${ANSWER} || return 1
            LVDEVICE=$(cat ${ANSWER})
            if [[ "$(lvs -o lv_name,vg_name --noheading 2>/dev/null | grep " $(echo ${LVDEVICE}) $(echo ${LV})"$)" ]]; then
                DIALOG --msgbox "ERROR: You have defined 2 identical Logical Volume names! Please enter another name." 8 65
                LVDEVICE=""
            fi
        done
        while [[ "${LV_SIZE_SET}" = "" ]]; do
            LV_ALL=""
            DIALOG --inputbox "Enter the size (MB) of your Logical Volume,\nMinimum value is > 0.\n\nVolume space left: $(vgs -o vg_free --noheading --units m ${LV})B\n\nIf you enter no value, all free space left will be used." 10 65 "" 2>${ANSWER} || return 1
                LV_SIZE=$(cat ${ANSWER})
                if [[ "${LV_SIZE}" = "" ]]; then
                    DIALOG --yesno "Would you like to create Logical Volume with no free space left?" 0 0 && LV_ALL="1"
                    if ! [[ "${LV_ALL}" = "1" ]]; then
                         LV_SIZE=0
                    fi
                fi
                if [[ "${LV_SIZE}" = "0" ]]; then
                    DIALOG --msgbox "ERROR: You have entered a invalid size, please enter again." 0 0
                else
                    if [[ "${LV_SIZE}" -ge "$(vgs -o vg_free --noheading --units m | sed -e 's#m##g')" ]]; then
                        DIALOG --msgbox "ERROR: You have entered a too large size, please enter again." 0 0
                    else
                        LV_SIZE_SET=1
                    fi
                fi
        done
        #Contiguous doesn't work with +100%FREE
        LV_CONTIGUOUS=""
        [[ "${LV_ALL}" = "" ]] && DIALOG --defaultno --yesno "Would you like to create Logical Volume as a contiguous partition, that means that your space doesn't get partitioned over one or more disks nor over non-contiguous physical extents.\n(usefull for swap space etc.)?" 0 0 && LV_CONTIGUOUS="1"
        if [[ "${LV_CONTIGUOUS}" = "1" ]]; then
            CONTIGUOUS=yes
            LV_EXTRA="-C y"
        else
            CONTIGUOUS=no
            LV_EXTRA=""
        fi
        [[ "${LV_SIZE}" = "" ]] && LV_SIZE="All free space left"
        # final step ask if everything is ok?
        DIALOG --yesno "Would you like to create Logical Volume ${LVDEVICE} like this?\nVolume Group:\n${LV}\nVolume Size:\n${LV_SIZE}\nContiguous Volume:\n${CONTIGUOUS}" 0 0 && LVFINISH="DONE"
    done
    DIALOG --infobox "Creating Logical Volume ${LVDEVICE}..." 0 0
    if [[ "${LV_ALL}" = "1" ]]; then
        lvcreate ${LV_EXTRA} -l +100%FREE ${LV} -n ${LVDEVICE} >${LOG} 2>&1
    else
        lvcreate ${LV_EXTRA} -L ${LV_SIZE} ${LV} -n ${LVDEVICE} >${LOG} 2>&1
    fi
    if [[ $? -gt 0 ]]; then
        DIALOG --msgbox "Error creating Logical Volume ${LVDEVICE} (see ${LOG} for details)." 0 0
        return 1
    fi
}

# enter luks name
_enter_luks_name() {
    LUKSDEVICE=""
    while [[ "${LUKSDEVICE}" = "" ]]; do
        DIALOG --inputbox "Enter the name for luks encrypted device ${PART}:\nfooname\n<yourname>\n\n" 15 65 "fooname" 2>${ANSWER} || return 1
        LUKSDEVICE=$(cat ${ANSWER})
        if ! [[ "$(cryptsetup status ${LUKSDEVICE} | grep inactive)" ]]; then
            DIALOG --msgbox "ERROR: You have defined 2 identical luks encryption device names! Please enter another name." 8 65
            LUKSDEVICE=""
        fi
    done
}

# enter luks passphrase
_enter_luks_passphrase () {
    LUKSPASSPHRASE=""
    while [[ "${LUKSPASSPHRASE}" = "" ]]; do
        DIALOG --insecure --passwordbox "Enter passphrase for luks encrypted device ${PART}:" 0 0 2>${ANSWER} || return 1
        LUKSPASS=$(cat ${ANSWER})
        DIALOG --insecure --passwordbox "Retype passphrase for luks encrypted device ${PART}:" 0 0 2>${ANSWER} || return 1
        LUKSPASS2=$(cat ${ANSWER})
        if [[ "${LUKSPASS}" = "${LUKSPASS2}" ]]; then
            LUKSPASSPHRASE=${LUKSPASS}
            echo ${LUKSPASSPHRASE} > /tmp/passphrase-${LUKSDEVICE}
            LUKSPASSPHRASE=/tmp/passphrase-${LUKSDEVICE}
        else
             DIALOG --msgbox "Passphrases didn't match, please enter again." 0 0
        fi
    done
}

# opening luks
_opening_luks() {
    DIALOG --infobox "Opening encrypted ${PART}..." 0 0
    luksOpen_success="0"
    while [[ "${luksOpen_success}" = "0" ]]; do
        cryptsetup luksOpen ${PART} ${LUKSDEVICE} >${LOG} <${LUKSPASSPHRASE} && luksOpen_success=1
        if [[ "${luksOpen_success}" = "0" ]]; then
            DIALOG --msgbox "Error: Passphrases didn't match, please enter again." 0 0
            _enter_luks_passphrase || return 1
        fi
    done
    DIALOG --yesno "Would you like to save the passphrase of luks device in /etc/$(basename ${LUKSPASSPHRASE})?\nName:${LUKSDEVICE}" 0 0 || LUKSPASSPHRASE="ASK"
    echo ${LUKSDEVICE} ${PART} /etc/$(basename ${LUKSPASSPHRASE}) >> /tmp/.crypttab
}

# help for luks
_helpluks()
{
DIALOG --msgbox "LUKS ENCRYPTION SUMMARY:\n
-----------------------------\n\n
Encryption is useful for two (related) reasons.\n
Firstly, it prevents anyone with physical access to your computer,\n
and your hard drive in particular, from getting the data from it\n
(unless they have your passphrase/key).\n
Secondly, it allows you to wipe the data on your hard drive with\n
far more confidence in the event of you selling or discarding\n
your drive.\n
Basically, it supplements the access control mechanisms of the operating\n
system (like file permissions) by making it harder to bypass the operating\n
system by inserting a boot CD, for example. Encrypting the root partition\n
prevents anyone from using this method to insert viruses or trojans onto\n
your computer.\n\n
ATTENTION:\n
Having encrypted partitions does not protect you from all possible\n
attacks. The encryption is only as good as your key management, and there\n
are other ways to break into computers, while they are running." 0 0
}

# create luks device
_luks()
{
    NAME_SCHEME_PARAMETER_RUN=""
    LUKSFINISH=""
    while [[ "${LUKSFINISH}" != "DONE" ]]; do
        activate_special_devices
        PARTS="$(findpartitions _)"
        ALREADYINUSE=""
        # skip already encrypted devices, device mapper!
        for devpath in $(ls /dev/mapper 2>/dev/null | grep -v control); do
            [[ "$(cryptsetup status ${devpath})" ]] && ALREADYINUSE="${ALREADYINUSE} /dev/mapper/${devpath}"
        done
        # skip already encrypted devices, device mapper with encrypted parts!
        for devpath in $(pvs -o pv_name --noheading); do
             if [[ "$(echo ${devpath} | grep dm-)" ]]; then
                if [[ "$(cryptsetup status $(basename ${devpath}))" ]]; then
                   killvolumegroup="$(echo $(pvs -o vg_name --noheading ${devpath}))"
                   ALREADYINUSE="${ALREADYINUSE} $(ls /dev/mapper/${killvolumegroup}-*)"
                fi
             fi
             # remove hidden crypt by md device
             if [[ "$(echo ${devpath} | grep /dev/md)" ]]; then
                 mdcheck="$(echo ${devpath} | sed -e 's#/dev/##g')"
                 if ! [[ "$(find ${block}/${mdcheck}/slaves/ -name 'dm*' 2>/dev/null)" = "" ]]; then
                     for k in $(find ${block}/${mdcheck}/slaves/ -name 'dm*'); do
                         if [[ "$(cryptsetup status $(cat ${k}/dm/name))" ]]; then
                             killvolumegroup="$(echo $(pvs -o vg_name --noheading ${devpath}))"
                             ALREADYINUSE="${ALREADYINUSE} $(ls /dev/mapper/${killvolumegroup}-*)"
                         fi
                     done
                 fi
             fi
        done
        # skip md devices, which already has encrypted devices!
        for i in ${PARTS}; do
            mdcheck="$(echo ${i} | sed -e 's#/dev/##g')"
            if ! [[ "$(find ${block}/${mdcheck}/slaves/ -name 'dm*' 2>/dev/null)" = "" ]]; then
                for k in $(find ${block}/${mdcheck}/slaves/ -name 'dm*' 2>/dev/null); do
                    [[ "$(cryptsetup status $(cat ${k}/dm/name))"  ]] && ALREADYINUSE="${ALREADYINUSE} ${i}"
                    # check lvm devices if encryption was used!
                    if [[ "$(lvs /dev/mapper/$(cat ${k}/dm/name) 2>/dev/null)" ]]; then
                        for devpath in ${ALREADYINUSE}; do
                            [[ "$(echo ${devpath} | grep "/dev/mapper/$(cat ${k}/dm/name)"$)" ]] && ALREADYINUSE="${ALREADYINUSE} ${i}"
                        done
                    fi
                done
            fi
        done
        # skip md partition devices, which already has encrypted devices!
        for i in ${PARTS}; do
            mdcheck="$(echo ${i} | grep /dev/md*p | sed -e 's#p.*##g' -e 's#/dev/##g')"
            if [[ "$(find ${block}/${mdcheck}/slaves/ -name 'dm*' 2>/dev/null)" != "" && "${mdcheck}" != "" ]]; then
                for k in $(find ${block}/${mdcheck}/slaves/ -name 'dm*' 2>/dev/null); do
                    [[ "$(cryptsetup status $(cat ${k}/dm/name))" ]] && ALREADYINUSE="${ALREADYINUSE} ${i}"
                    # check lvm devices if encryption was used!
                    if [[ "$(lvs /dev/mapper/$(cat ${k}/dm/name) 2>/dev/null)" ]]; then
                        for devpath in ${ALREADYINUSE}; do
                            [[ "$(echo ${devpath} | grep "/dev/mapper/$(cat ${k}/dm/name)"$)" ]] && ALREADYINUSE="${ALREADYINUSE} ${i}"
                        done
                    fi
                done
            fi
        done
        for i in ${ALREADYINUSE}; do
            PARTS=$(echo ${PARTS} | sed -e "s#${i}\ _##g")
        done
        # break if all devices are in use
        if [[ "${PARTS}" = "" ]]; then
            DIALOG --msgbox "No devices left for luks encryption." 0 0
            return 1
        fi
        # show all devices with sizes
        DIALOG --msgbox "DISKS:\n$(_getavaildisks)\n\nPARTITIONS:\n$(_getavailpartitions)\n\n" 0 0
        DIALOG --menu "Select device for luks encryption" 21 50 13 ${PARTS} 2>${ANSWER} || return 1
        PART=$(cat ${ANSWER})
        # enter luks name
        _enter_luks_name
        ### TODO: offer more options for encrypt!
        # final step ask if everything is ok?
        DIALOG --yesno "Would you like to encrypt luks device below?\nName:${LUKSDEVICE}\nDevice:${PART}\n" 0 0 && LUKSFINISH="DONE"
    done
    _enter_luks_passphrase
    DIALOG --infobox "Encrypting ${PART}..." 0 0
    cryptsetup -c aes-cbc-essiv:sha256 -s 128 luksFormat ${PART} >${LOG} <${LUKSPASSPHRASE}
    _opening_luks
}

autoprepare() {
    # check on encrypted devices, else weird things can happen!
    _stopluks
    # check on raid devices, else weird things can happen during partitioning!
    _stopmd
    # check on lvm devices, else weird things can happen during partitioning!
    _stoplvm
    NAME_SCHEME_PARAMETER_RUN=""
    # switch for mbr usage
    set_guid
    DISCS=$(default_blockdevices)
    if [[ "$(echo ${DISCS} | wc -w)" -gt 1 ]]; then
        DIALOG --msgbox "Available Disks:\n\n$(_getavaildisks)\n" 0 0
        DIALOG --menu "Select the hard drive to use" 14 55 7 $(default_blockdevices _) 2>${ANSWER} || return 1
        DISC=$(cat ${ANSWER})
    else
        DISC=${DISCS}
    fi
    DEFAULTFS=""
    BOOT_PART_SET=""
    SWAP_PART_SET=""
    ROOT_PART_SET=""
    CHOSEN_FS=""
    # get just the disk size in 1000*1000 MB
    if [[ "$(cat ${block}/$(basename ${DISC} 2>/dev/null)/size 2>/dev/null)" ]]; then
        DISC_SIZE="$(($(expr $(cat ${block}/$(basename ${DISC})/queue/logical_block_size) '*' $(cat ${block}/$(basename ${DISC})/size))/1000000))"
    else
        DIALOG --msgbox "ERROR: Setup cannot detect size of your device, please use normal installation routine for partitioning and mounting devices." 0 0
        return 1
    fi
    while [[ "${DEFAULTFS}" = "" ]]; do
        FSOPTS=""
        [[ "$(which mkfs.ext2 2>/dev/null)" ]] && FSOPTS="${FSOPTS} ext2 Ext2"
        [[ "$(which mkfs.ext3 2>/dev/null)" ]] && FSOPTS="${FSOPTS} ext3 Ext3"
        [[ "$(which mkfs.ext4 2>/dev/null)" ]] && FSOPTS="${FSOPTS} ext4 Ext4"
        [[ "$(which mkfs.btrfs 2>/dev/null)" ]] && FSOPTS="${FSOPTS} btrfs Btrfs-(Experimental)"
        [[ "$(which mkfs.nilfs2 2>/dev/null)" ]] && FSOPTS="${FSOPTS} nilfs2 Nilfs2-(Experimental)"
        [[ "$(which mkreiserfs 2>/dev/null)" ]] && FSOPTS="${FSOPTS} reiserfs Reiser3"
        [[ "$(which mkfs.xfs 2>/dev/null)" ]] && FSOPTS="${FSOPTS} xfs XFS"
        [[ "$(which mkfs.jfs 2>/dev/null)" ]] && FSOPTS="${FSOPTS} jfs JFS"
        # create 1 MB bios_grub partition for grub-bios GPT support
        if [[ "${GUIDPARAMETER}" = "yes" ]]; then
            GUID_PART_SIZE="2"
            GPT_BIOS_GRUB_PART_SIZE="${GUID_PART_SIZE}"
            UEFISYS_PART_SIZE="512"
        else
            GUID_PART_SIZE="0"
            UEFISYS_PART_SIZE="0"
        fi
        DISC_SIZE=$((${DISC_SIZE}-${GUID_PART_SIZE}-${UEFISYS_PART_SIZE}))
        while [[ "${BOOT_PART_SET}" = "" ]]; do
            DIALOG --inputbox "Enter the size (MB) of your /boot partition,\nMinimum value is 16.\n\nDisk space left: ${DISC_SIZE} MB" 10 65 "512" 2>${ANSWER} || return 1
            BOOT_PART_SIZE="$(cat ${ANSWER})"
            if [[ "${BOOT_PART_SIZE}" = "" ]]; then
                DIALOG --msgbox "ERROR: You have entered a invalid size, please enter again." 0 0
            else
                if [[ "${BOOT_PART_SIZE}" -ge "${DISC_SIZE}" || "${BOOT_PART_SIZE}" -lt "16" || "${SBOOT_PART_SIZE}" = "${DISC_SIZE}" ]]; then
                    DIALOG --msgbox "ERROR: You have entered an invalid size, please enter again." 0 0
                else
                    BOOT_PART_SET=1
                fi
            fi
        done
        DISC_SIZE=$((${DISC_SIZE}-${BOOT_PART_SIZE}))
        SWAP_SIZE="256"
        [[ "${DISC_SIZE}" -lt "256" ]] && SWAP_SIZE="${DISC_SIZE}"
        while [[ "${SWAP_PART_SET}" = "" ]]; do
            DIALOG --inputbox "Enter the size (MB) of your swap partition,\nMinimum value is > 0.\n\nDisk space left: ${DISC_SIZE} MB" 10 65 "${SWAP_SIZE}" 2>${ANSWER} || return 1
            SWAP_PART_SIZE=$(cat ${ANSWER})
            if [[ "${SWAP_PART_SIZE}" = "" || "${SWAP_PART_SIZE}" = "0" ]]; then
                DIALOG --msgbox "ERROR: You have entered an invalid size, please enter again." 0 0
            else
                if [[ "${SWAP_PART_SIZE}" -ge "${DISC_SIZE}" ]]; then
                    DIALOG --msgbox "ERROR: You have entered a too large size, please enter again." 0 0
                else
                    SWAP_PART_SET=1
                fi
            fi
        done
        DISC_SIZE=$((${DISC_SIZE}-${SWAP_PART_SIZE}))
        ROOT_SIZE="7500"
        [[ "${DISC_SIZE}" -lt "7500" ]] && ROOT_SIZE="${DISC_SIZE}"
        while [[ "${ROOT_PART_SET}" = "" ]]; do
        DIALOG --inputbox "Enter the size (MB) of your / partition,\nthe /home partition will use the remaining space.\n\nDisk space left:  ${DISC_SIZE} MB" 10 65 "${ROOT_SIZE}" 2>${ANSWER} || return 1
        ROOT_PART_SIZE=$(cat ${ANSWER})
            if [[ "${ROOT_PART_SIZE}" = "" || "${ROOT_PART_SIZE}" = "0" ]]; then
                DIALOG --msgbox "ERROR: You have entered an invalid size, please enter again." 0 0
            else
                if [[ "${ROOT_PART_SIZE}" -ge "${DISC_SIZE}" ]]; then
                    DIALOG --msgbox "ERROR: You have entered a too large size, please enter again." 0 0
                else
                    DIALOG --yesno "$((${DISC_SIZE}-${ROOT_PART_SIZE})) MB will be used for your /home partition. Is this OK?" 0 0 && ROOT_PART_SET=1
                fi
            fi
        done
        while [[ "${CHOSEN_FS}" = "" ]]; do
            DIALOG --menu "Select a filesystem for / and /home:" 16 45 8 ${FSOPTS} 2>${ANSWER} || return 1
            FSTYPE=$(cat ${ANSWER})
            DIALOG --yesno "${FSTYPE} will be used for / and /home. Is this OK?" 0 0 && CHOSEN_FS=1
        done
        DEFAULTFS=1
    done
    DIALOG --defaultno --yesno "${DISC} will be COMPLETELY ERASED!  Are you absolutely sure?" 0 0 \
    || return 1
    DEVICE=${DISC}

    # validate DEVICE
    if [[ ! -b "${DEVICE}" ]]; then
      DIALOG --msgbox "Device '${DEVICE}' is not valid" 0 0
      return 1
    fi

    # validate DEST
    if [[ ! -d "${DESTDIR}" ]]; then
        DIALOG --msgbox "Destination directory '${DESTDIR}' is not valid" 0 0
        return 1
    fi

    [[ -e /tmp/.fstab ]] && rm -f /tmp/.fstab
    # disable swap and all mounted partitions, umount / last!
    _umountall
    # we assume a /dev/hdX format (or /dev/sdX)
    if [[ "${GUIDPARAMETER}" == "yes" ]]; then
        PART_ROOT="${DEVICE}5"
        # GPT (GUID) is supported only by 'parted' or 'sgdisk'
        printk off
        DIALOG --infobox "Partitioning ${DEVICE}" 0 0
        # clean partition table to avoid issues!
        sgdisk --zap ${DEVICE} &>/dev/null
        # clear all magic strings/signatures - mdadm, lvm, partition tables etc.
        dd if=/dev/zero of=${DEVICE} bs=512 count=2048 &>/dev/null
        wipefs -a ${DEVICE} &>/dev/null
        # create fresh GPT
        sgdisk --clear ${DEVICE} &>/dev/null
        # create actual partitions
        sgdisk --set-alignment="2048" --new=1:1M:+${GPT_BIOS_GRUB_PART_SIZE}M --typecode=1:EF02 --change-name=1:BIOS_GRUB ${DEVICE} > ${LOG}
        sgdisk --set-alignment="2048" --new=2:+1M:+${UEFISYS_PART_SIZE}M --typecode=2:EF00 --change-name=2:UEFI_SYSTEM ${DEVICE} > ${LOG}
        sgdisk --set-alignment="2048" --new=3:+1M:+${BOOT_PART_SIZE}M --typecode=3:8300 --attributes=3:set:2 --change-name=3:MANJARO_BOOT ${DEVICE} > ${LOG}
        sgdisk --set-alignment="2048" --new=4:+1M:+${SWAP_PART_SIZE}M --typecode=4:8200 --change-name=4:MANJARO_SWAP ${DEVICE} > ${LOG}
        sgdisk --set-alignment="2048" --new=5:+1M:+${ROOT_PART_SIZE}M --typecode=5:8300 --change-name=5:MANJARO_ROOT ${DEVICE} > ${LOG}
        sgdisk --set-alignment="2048" --new=6:+1M:0 --typecode=6:8300 --change-name=6:MANJARO_HOME ${DEVICE} > ${LOG}
        sgdisk --print ${DEVICE} > ${LOG}
    else
        PART_ROOT="${DEVICE}3"
        # start at sector 1 for 4k drive compatibility and correct alignment
        printk off
        DIALOG --infobox "Partitioning ${DEVICE}" 0 0
        # clean partitiontable to avoid issues!
        dd if=/dev/zero of=${DEVICE} bs=512 count=2048 >/dev/null 2>&1
        wipefs -a ${DEVICE} &>/dev/null
        # create DOS MBR with parted
        parted -a optimal -s ${DEVICE} unit MiB mktable msdos >/dev/null 2>&1
        parted -a optimal -s ${DEVICE} unit MiB mkpart primary 1 $((${GUID_PART_SIZE}+${BOOT_PART_SIZE})) >${LOG}
        parted -a optimal -s ${DEVICE} unit MiB set 1 boot on >${LOG}
        parted -a optimal -s ${DEVICE} unit MiB mkpart primary $((${GUID_PART_SIZE}+${BOOT_PART_SIZE}+1)) $((${GUID_PART_SIZE}+${BOOT_PART_SIZE}+${SWAP_PART_SIZE}+1)) >${LOG}
        parted -a optimal -s ${DEVICE} unit MiB mkpart primary $((${GUID_PART_SIZE}+${BOOT_PART_SIZE}+${SWAP_PART_SIZE}+2)) $((${GUID_PART_SIZE}+${BOOT_PART_SIZE}+${SWAP_PART_SIZE}+${ROOT_PART_SIZE}+2)) >${LOG}
        parted -a optimal -s ${DEVICE} unit MiB mkpart primary $((${GUID_PART_SIZE}+${BOOT_PART_SIZE}+${SWAP_PART_SIZE}+${ROOT_PART_SIZE}+3)) 100% >${LOG}
    fi
    if [[ $? -gt 0 ]]; then
        DIALOG --msgbox "Error partitioning ${DEVICE} (see ${LOG} for details)" 0 0
        printk on
        return 1
    fi
    printk on
    ## wait until /dev initialized correct devices
    udevadm settle

    if [[ "${NAME_SCHEME_PARAMETER_RUN}" == "" ]]; then
        set_device_name_scheme || return 1
    fi
    ## FSSPECS - default filesystem specs (the + is bootable flag)
    ## <partnum>:<mountpoint>:<partsize>:<fstype>[:<fsoptions>][:+]:labelname
    ## The partitions in FSSPECS list should be listed in the "mountpoint" order.
    ## Make sure the "root" partition is defined first in the FSSPECS list
    FSSPECS="3:/:${ROOT_PART_SIZE}:${FSTYPE}:::ROOT_MANJARO 1:/boot:${BOOT_PART_SIZE}:ext2::+:BOOT_MANJARO 4:/home:*:${FSTYPE}:::HOME_MANJARO 2:swap:${SWAP_PART_SIZE}:swap:::SWAP_MANJARO"

    if [[ "${GUIDPARAMETER}" == "yes" ]]; then
        FSSPECS="5:/:${ROOT_PART_SIZE}:${FSTYPE}:::ROOT_MANJARO 3:/boot:${BOOT_PART_SIZE}:ext2::+:BOOT_MANJARO 2:/boot/efi:512:vfat:-F32::ESP 6:/home:*:${FSTYPE}:::HOME_MANJARO 4:swap:${SWAP_PART_SIZE}:swap:::SWAP_MANJARO"
    fi

    ## make and mount filesystems
    for fsspec in ${FSSPECS}; do
        part="$(echo ${fsspec} | tr -d ' ' | cut -f1 -d:)"
        mountpoint="$(echo ${fsspec} | tr -d ' ' | cut -f2 -d:)"
        fstype="$(echo ${fsspec} | tr -d ' ' | cut -f4 -d:)"
        fsoptions="$(echo ${fsspec} | tr -d ' ' | cut -f5 -d:)"
        [[ "${fsoptions}" == "" ]] && fsoptions="NONE"
        labelname="$(echo ${fsspec} | tr -d ' ' | cut -f7 -d:)"
        btrfsdevices="${DEVICE}${part}"
        btrfsssd="NONE"
        btrfscompress="NONE"
        btrfssubvolume="NONE"
        btrfslevel="NONE"
        dosubvolume="no"
        # if echo "${mountpoint}" | tr -d ' ' | grep '^/$' 2>&1 >/dev/null; then
        # if [[ "$(echo ${mountpoint} | tr -d ' ' | grep '^/$' | wc -l)" -eq 0 ]]; then
        DIALOG --infobox "Creating ${fstype} on ${DEVICE}${part}\nwith FSLABEL ${labelname} .\nMountpoint is ${mountpoint} ." 0 0
        _mkfs yes "${DEVICE}${part}" "${fstype}" "${DESTDIR}" "${mountpoint}" "${labelname}" "${fsoptions}" "${btrfsdevices}" "${btrfssubvolume}" "${btrfslevel}" "${dosubvolume}" "${btrfssd}" "${btrfscompress}" || return 1
        # fi
    done

    DIALOG --msgbox "Auto-prepare was successful" 0 0
    S_MKFSAUTO=1
}

check_gpt() {
    GUID_DETECTED=""
    [[ "$(${_BLKID} -p -i -o value -s PTTYPE ${DISC})" == "gpt" ]] && GUID_DETECTED="1"
    
    if [[ "${GUID_DETECTED}" == "" ]]; then
        DIALOG --defaultno --yesno "Setup detected no GUID (gpt) partition table on ${DISC}.\n\nDo you want to convert the existing MBR table in ${DISC} to a GUID (gpt) partition table?\n\nNOTE:\nBIOS-GPT boot may not work in some Lenovo systems (irrespective of the bootloader used). " 0 0 || return 1
        sgdisk --mbrtogpt ${DISC} > ${LOG} && GUID_DETECTED="1"
    fi
    
    if [[ "${GUID_DETECTED}" == "1" ]]; then
        if [[ "${CHECK_UEFISYS_PART}" == "1" ]]; then
            check_uefisyspart
        fi
        
        if [[ "${CHECK_BIOS_BOOT_GRUB}" == "1" ]]; then
            if ! [[ "$(sgdisk -p ${DISC} | grep 'EF02')" ]]; then
                DIALOG --msgbox "Setup detected no BIOS BOOT PARTITION in ${DISC}. Please create a >=1 MB BIOS Boot partition for grub-bios GPT support." 0 0
                RUN_CGDISK="1"
            fi
        fi
    fi
    
    if [[ "${RUN_CGDISK}" == "1" ]]; then
        DIALOG --msgbox "Now you'll be put into cgdisk where you can partition your hard drive.\nYou should make a swap partition and as many data partitions as you will need." 18 70
        clear && cgdisk ${DISC}
    fi
}

## check and mount UEFI SYSTEM PARTITION at /boot/efi
check_uefisyspart() {
    
    if [[ "$(${_BLKID} -p -i -o value -s PTTYPE ${DISC})" != "gpt" ]]; then
        DIALOG --msgbox "Setup detected no GUID (gpt) partition table on ${DISC}.\nUEFI boot requires ${DISC} to be partitioned as GPT.\nSetup will now try to non-destructively convert ${DISC} to GPT using sgdisk." 0 0
        sgdisk --mbrtogpt "${DISC}" > "${LOG}" && GUID_DETECTED="1"
    fi
    
    if [[ ! "$(sgdisk -p ${DISC} | grep 'EF00')" ]]; then
        DIALOG --msgbox "Setup detected no UEFI SYSTEM PARTITION in ${DISC}. You will now be put into cgdisk. Please create a >=512 MiB partition with gdisk type code EF00 .\nWhen prompted (later) to format as FAT32, say Yes.\nIf you already have a >=512 MiB FAT32 UEFI SYSTEM Partition, check whether that partition has EF00 gdisk type code." 0 0
        clear && cgdisk "${DISC}"
        RUN_CGDISK=""
    fi
    
    if [[ "$(sgdisk -p ${DISC} | grep 'EF00')" ]]; then
        UEFISYS_PART_NUM="$(sgdisk -p ${DISC} | grep 'EF00' | tail -n +1 | awk '{print $1}')"
        UEFISYS_PART="${DISC}${UEFISYS_PART_NUM}"
        
        if [[ "$(${_BLKID} -p -i -o value -s TYPE ${UEFISYS_PART})" == "vfat" ]]; then
            if [[ "$(${_BLKID} -p -i -o value -s VERSION ${UEFISYS_PART})" != "FAT32" ]]; then
                ## Check whether UEFISYS is FAT32 (specifically), otherwise warn the user (but do not exit).
                DIALOG --defaultno --yesno "UEFI SYSTEM PARTIION ${UEFISYS_PART} is not FAT32 formatted. Some UEFI firmwares may not work properly with a FAT16 or FAT12 filesystem in the UEFISYS partition.\nDo you want to format ${UEFISYS_PART} as FAT32?" 0 0 && _FORMAT_UEFISYS_FAT32="1"
            fi
        else
            ## Check whether UEFISYS is FAT, otherwise inform the user and offer to format the partition as FAT32.
            DIALOG --defaultno --yesno "UEFI Specification requires UEFI SYSTEM PARTIION to be formatted as FAT32.\nDo you want to format ${UEFISYS_PART} as FAT32?" 0 0 && _FORMAT_UEFISYS_FAT32="1"
        fi
        
        umount "${DESTDIR}/boot/efi" &> /dev/null
        umount "${UEFISYS_PART}" &> /dev/null
        rm -rf "${DESTDIR}/boot/efi"
        
        if [[ "${_FORMAT_UEFISYS_FAT32}" == "1" ]]; then
            mkfs.vfat -F32 -n "ESP" "${UEFISYS_PART}"
        fi
        
        mkdir -p "${DESTDIR}/boot/efi"
        
        if [[ "$(${_BLKID} -p -i -o value -s TYPE ${UEFISYS_PART})" == "vfat" ]]; then
            mount -o rw,flush -t vfat "${UEFISYS_PART}" "${DESTDIR}/boot/efi"
        else
            DIALOG --msgbox "${UEFISYS_PART} is not formatted using FAT filesystem. Setup will go ahead but there might be issues using non-FAT FS for UEFISYS partition." 0 0
            
            mount -o rw "${UEFISYS_PART}" "${DESTDIR}/boot/efi"
        fi
        
        ## Fix (possible) case-sensitivity issues
        if [[ -d "${DESTDIR}/boot/efi/efi" ]]; then
            mv "${DESTDIR}/boot/efi/efi" "${DESTDIR}/boot/efi/EFI_"
            mv "${DESTDIR}/boot/efi/EFI_" "${DESTDIR}/boot/efi/EFI"
        fi
        
        [[ ! -d "${DESTDIR}/boot/efi/EFI" ]] && mkdir -p "${DESTDIR}/boot/efi/EFI"
    else
        DIALOG --msgbox "Setup did not find any UEFI SYSTEM PARTITION in ${DISC}. Please create a >=512MiB FAT32 partition with gdisk type code EFOO and try again." 0 0
        return 1
    fi
    
}

partition() {
    # disable swap and all mounted partitions, umount / last!
    _umountall
    # check on encrypted devices, else weird things can happen!
    _stopluks
    # check on raid devices, else weird things can happen during partitioning!
    _stopmd
    # check on lvm devices, else weird things can happen during partitioning!
    _stoplvm
    # update dmraid
    _dmraid_update
    # switch for mbr usage
    set_guid
    # Select disk to partition
    DISCS=$(finddisks _)
    DISCS="${DISCS} OTHER _ DONE +"
    DIALOG --msgbox "Available Disks:\n\n$(_getavaildisks)\n" 0 0
    DISC=""
    while true; do
        # Prompt the user with a list of known disks
        DIALOG --menu "Select the disk you want to partition\n(select DONE when finished)" 14 55 7 ${DISCS} 2>${ANSWER} || return 1
        DISC=$(cat ${ANSWER})
        if [[ "${DISC}" == "OTHER" ]]; then
            DIALOG --inputbox "Enter the full path to the device you wish to partition" 8 65 "/dev/sda" 2>${ANSWER} || DISC=""
            DISC=$(cat ${ANSWER})
        fi
        # Leave our loop if the user is done partitioning
        [[ "${DISC}" == "DONE" ]] && break
        MSDOS_DETECTED=""
        if ! [[ "${DISC}" == "" ]]; then
            if [[ "${GUIDPARAMETER}" == "yes" ]]; then
                CHECK_BIOS_BOOT_GRUB=""
                CHECK_UEFISYS_PART=""
                RUN_CGDISK="1"
                check_gpt
            else
                [[ "$(${_BLKID} -p -i -o value -s PTTYPE ${DISC})" == "dos" ]] && MSDOS_DETECTED="1"
                
                if [[ "${MSDOS_DETECTED}" == "" ]]; then
                    DIALOG --defaultno --yesno "Setup detected no MS-DOS partition table on ${DISC}.\nDo you want to create a MS-DOS partition table now on ${DISC}?\n\n${DISC} will be COMPLETELY ERASED!  Are you absolutely sure?" 0 0 || return 1
                    # clean partitiontable to avoid issues!
                    dd if=/dev/zero of=${DEVICE} bs=512 count=2048 >/dev/null 2>&1
                    wipefs -a ${DEVICE} /dev/null 2>&1
                    parted -a optimal -s ${DISC} mktable msdos >${LOG}
                fi
                # Partition disc
                DIALOG --msgbox "Now you'll be put into the parted shell where you can partition your hard drive. You should make a swap partition and as many data partitions as you will need.\n\nShort command list:\n- 'help' to get help text\n- 'print' to show  partition table\n- 'mkpart' for new partition\n- 'rm' for deleting a partition\n- 'quit' to leave parted\n\nNOTE: parted may tell you to reboot after creating partitions.  If you need to reboot, just re-enter this install program, skip this step and go on." 18 70
                clear
                ## Use parted for correct alignment, cfdisk does not align correct!
                parted ${DISC} print
                parted ${DISC}
            fi
        fi
    done
    # update dmraid
    _dmraid_update
    NEXTITEM="4"
    S_PART=1
}

# scan and update btrfs devices
btrfs_scan() {
    btrfs device scan >/dev/null 2>&1
}

# mount btrfs for checks
mount_btrfs() {
    btrfs_scan
    BTRFSMP="$(mktemp -d /tmp/brtfsmp.XXXX)"
    mount ${PART} ${BTRFSMP}
}

# unmount btrfs after checks done
umount_btrfs() {
    umount ${BTRFSMP}
    rm -r ${BTRFSMP}
}

# Set BTRFS_DEVICES on detected btrfs devices
find_btrfs_raid_devices() {
    btrfs_scan
    if [[ "${DETECT_CREATE_FILESYSTEM}" = "no" && "${FSTYPE}" = "btrfs" ]]; then
        for i in $(btrfs filesystem show ${PART} | cut -d " " -f 11); do
            BTRFS_DEVICES="${BTRFS_DEVICES}#${i}"
        done
    fi
}

find_btrfs_raid_bootloader_devices() {
    btrfs_scan
    BTRFS_COUNT=1
    if [[ "$(${_BLKID} -p -i  ${bootdev} -o value -s TYPE)" = "btrfs" ]]; then
        BTRFS_DEVICES=""
        for i in $(btrfs filesystem show ${bootdev} | cut -d " " -f 11); do
            BTRFS_DEVICES="${BTRFS_DEVICES}#${i}"
            BTRFS_COUNT=$((${BTRFS_COUNT}+1))
        done
    fi
}

# find btrfs subvolume
find_btrfs_subvolume() {
    if [[ "${DETECT_CREATE_FILESYSTEM}" = "no" ]]; then
        # existing btrfs subvolumes
        mount_btrfs
        for i in $(btrfs subvolume list ${BTRFSMP} | cut -d " " -f 7); do
            echo ${i}
            [[ "${1}" ]] && echo ${1}
        done
        umount_btrfs
    fi
}

find_btrfs_bootloader_subvolume() {
    BTRFS_SUBVOLUME_COUNT=1
    if [[ "$(${_BLKID} -p -i ${bootdev} -o value -s TYPE)" = "btrfs" ]]; then
        BTRFS_SUBVOLUMES=""
        PART="${bootdev}"
        mount_btrfs
        for i in $(btrfs subvolume list ${BTRFSMP} | cut -d " " -f 7); do
            BTRFS_SUBVOLUMES="${BTRFS_SUBVOLUMES}#${i}"
            BTRFS_SUBVOLUME_COUNT=$((${BTRFS_COUNT}+1))
        done
        umount_btrfs
    fi
}

# subvolumes already in use
subvolumes_in_use() {
    SUBVOLUME_IN_USE=""
    for i in $(grep ${PART}[:#] /tmp/.parts); do
        if [[ "$(echo ${i} | grep ":btrfs:")" ]]; then
            SUBVOLUME_IN_USE="${SUBVOLUME_IN_USE} $(echo ${i} | cut -d: -f 9)"
        fi
    done
}

# ask for btrfs compress option
btrfs_compress() {
    BTRFS_COMPRESS="NONE"
    BTRFS_COMPRESSLEVELS="lzo - zlib -"
    if [[ "${BTRFS_SUBVOLUME}" = "NONE" ]]; then
        DIALOG --defaultno --yesno "Would you like to compress the data on ${PART}?" 0 0 && BTRFS_COMPRESS="compress"
    else
        DIALOG --defaultno --yesno "Would you like to compress the data on ${PART} subvolume=${BTRFS_SUBVOLUME}?" 0 0 && BTRFS_COMPRESS="compress"
    fi
    if [[ "${BTRFS_COMPRESS}" = "compress" ]]; then
        DIALOG --menu "Select the compression method you want to use" 21 50 9 ${BTRFS_COMPRESSLEVELS} 2>${ANSWER} || return 1
        BTRFS_COMPRESS="compress=$(cat ${ANSWER})"
    fi
}

# ask for btrfs ssd option
btrfs_ssd() {
    BTRFS_SSD="NONE"
    if [[ "${BTRFS_SUBVOLUME}" = "NONE" ]]; then
        DIALOG --defaultno --yesno "Would you like to optimize the data for ssd disk usage on ${PART}?" 0 0 && BTRFS_SSD="ssd"
    else
        DIALOG --defaultno --yesno "Would you like to optimize the data for ssd disk usage on ${PART} subvolume=${BTRFS_SUBVOLUME}?" 0 0 && BTRFS_SSD="ssd"
    fi
}

# values that are only needed for btrfs creation
clear_btrfs_values() {
    : >/tmp/.btrfs-devices
    LABEL_NAME=""
    FS_OPTIONS=""
    BTRFS_DEVICES=""
    BTRFS_LEVEL=""
}

# do not ask for btrfs filesystem creation, if already prepared for creation!
check_btrfs_filesystem_creation() {
    DETECT_CREATE_FILESYSTEM="no"
    SKIP_FILESYSTEM="no"
    SKIP_ASK_SUBVOLUME="no"
    for i in $(grep ${PART}[:#] /tmp/.parts); do
        if [[ "$(echo ${i} | grep ":btrfs:")" ]]; then
            FSTYPE="btrfs"
            SKIP_FILESYSTEM="yes"
            # check on filesystem creation, skip subvolume asking then!
            [[ "$(echo ${i} | cut -d: -f 4 | grep yes)" ]] && DETECT_CREATE_FILESYSTEM="yes"
            [[ "${DETECT_CREATE_FILESYSTEM}" = "yes" ]] && SKIP_ASK_SUBVOLUME="yes"
        fi
    done
}

# remove devices with no subvolume from list and generate raid device list
btrfs_parts() {
     if [[ -s /tmp/.btrfs-devices ]]; then
         BTRFS_DEVICES=""
         for i in $(cat /tmp/.btrfs-devices); do
             BTRFS_DEVICES="${BTRFS_DEVICES}#${i}"
             # remove device if no subvolume is used!
             [[ "${BTRFS_SUBVOLUME}" = "NONE"  ]] && PARTS="$(echo ${PARTS} | sed -e "s#${i}\ _##g")"
         done
     else
         [[ "${BTRFS_SUBVOLUME}" = "NONE"  ]] && PARTS="$(echo ${PARTS} | sed -e "s#${PART}\ _##g")"
     fi
}

# choose raid level to use on btrfs device
btrfs_raid_level() {
    BTRFS_RAIDLEVELS="NONE - raid0 - raid1 - raid10 - single -"
    BTRFS_RAID_FINISH=""
    BTRFS_LEVEL=""
    BTRFS_DEVICE="${PART}"
    : >/tmp/.btrfs-devices
    DIALOG --msgbox "BTRFS RAID OPTIONS:\n\nBTRFS has options to control the raid configuration for data and metadata.\nValid choices are raid0, raid1, raid10 and single.\nsingle means that no duplication of metadata is done, which may be desired when using hardware raid. raid10 requires at least 4 devices.\n\nIf you don't need this feature select NONE." 0 0
    while [[ "${BTRFS_RAID_FINISH}" != "DONE" ]]; do
        DIALOG --menu "Select the raid level you want to use" 21 50 9 ${BTRFS_RAIDLEVELS} 2>${ANSWER} || return 1
        BTRFS_LEVEL=$(cat ${ANSWER})
        if [[ "${BTRFS_LEVEL}" = "NONE" ]]; then
            echo "${BTRFS_DEVICE}" >>/tmp/.btrfs-devices
            break
        else
            # take selected device as 1st device, add additional devices in part below.
            select_btrfs_raid_devices
        fi
    done
}

# select btrfs raid devices
select_btrfs_raid_devices () {
    # show all devices with sizes
    # DIALOG --msgbox "DISKS:\n$(_getavaildisks)\n\nPARTITIONS:\n$(_getavailpartitions)" 0 0
    # select the second device to use, no missing option available!
    : >/tmp/.btrfs-devices
    BTRFS_PART="${BTRFS_DEVICE}"
    BTRFS_PARTS="${PARTS}"
    echo "${BTRFS_PART}" >>/tmp/.btrfs-devices
    BTRFS_PARTS="$(echo ${BTRFS_PARTS} | sed -e "s#${BTRFS_PART}\ _##g")"
    RAIDNUMBER=2
    DIALOG --menu "Select device ${RAIDNUMBER}" 21 50 13 ${BTRFS_PARTS} 2>${ANSWER} || return 1
    BTRFS_PART=$(cat ${ANSWER})
    echo "${BTRFS_PART}" >>/tmp/.btrfs-devices
    while [[ "${BTRFS_PART}" != "DONE" ]]; do
        BTRFS_DONE=""
        RAIDNUMBER=$((${RAIDNUMBER} + 1))
        # RAID10 need 4 devices!
        [[ "${RAIDNUMBER}" -ge 3 && ! "${BTRFS_LEVEL}" = "raid10" ]] && BTRFS_DONE="DONE _"
        [[ "${RAIDNUMBER}" -ge 5 && "${BTRFS_LEVEL}" = "raid10" ]] && BTRFS_DONE="DONE _"
        # clean loop from used partition and options
        BTRFS_PARTS="$(echo ${BTRFS_PARTS} | sed -e "s#${BTRFS_PART}\ _##g")"
        # add more devices
        DIALOG --menu "Select device ${RAIDNUMBER}" 21 50 13 ${BTRFS_PARTS} ${BTRFS_DONE} 2>${ANSWER} || return 1
        BTRFS_PART=$(cat ${ANSWER})
        [[ "${BTRFS_PART}" = "DONE" ]] && break
        echo "${BTRFS_PART}" >>/tmp/.btrfs-devices
     done
     # final step ask if everything is ok?
     DIALOG --yesno "Would you like to create btrfs raid like this?\n\nLEVEL:\n${BTRFS_LEVEL}\n\nDEVICES:\n$(for i in $(cat /tmp/.btrfs-devices); do echo "${i}\n"; done)" 0 0 && BTRFS_RAID_FINISH="DONE"
}

# prepare new btrfs device
prepare_btrfs() {
    btrfs_raid_level || return 1
    prepare_btrfs_subvolume || return 1
}

# prepare btrfs subvolume
prepare_btrfs_subvolume() {
    DOSUBVOLUME="no"
    BTRFS_SUBVOLUME="NONE"
    if [[ "${SKIP_ASK_SUBVOLUME}" = "no" ]]; then
        DIALOG --defaultno --yesno "Would you like to create a new subvolume on ${PART}?" 0 0 && DOSUBVOLUME="yes"
    else
        DOSUBVOLUME="yes"
    fi
    if [[ "${DOSUBVOLUME}" = "yes" ]]; then
        BTRFS_SUBVOLUME="NONE"
        while [[ "${BTRFS_SUBVOLUME}" = "NONE" ]]; do
            DIALOG --inputbox "Enter the SUBVOLUME name for the device, keep it short\nand use no spaces or special\ncharacters." 10 65 2>${ANSWER} || return 1
            BTRFS_SUBVOLUME=$(cat ${ANSWER})
            check_btrfs_subvolume
        done
    else
        BTRFS_SUBVOLUME="NONE"
    fi
}

# check btrfs subvolume
check_btrfs_subvolume(){
    [[ "${DOMKFS}" = "yes" && "${FSTYPE}" = "btrfs" ]] && DETECT_CREATE_FILESYSTEM="yes"
    if [[ "${DETECT_CREATE_FILESYSTEM}" = "no" ]]; then
        mount_btrfs
        for i in $(btrfs subvolume list ${BTRFSMP} | cut -d " " -f 7); do
            if [[ "$(echo ${i} | grep "${BTRFS_SUBVOLUME}"$)" ]]; then
                DIALOG --msgbox "ERROR: You have defined 2 identical SUBVOLUME names or an empty name! Please enter another name." 8 65
                BTRFS_SUBVOLUME="NONE"
            fi
        done
        umount_btrfs
    else
        subvolumes_in_use
        if [[ "$(echo ${SUBVOLUME_IN_USE} | egrep "${BTRFS_SUBVOLUME}")" ]]; then
            DIALOG --msgbox "ERROR: You have defined 2 identical SUBVOLUME names or an empty name! Please enter another name." 8 65
            BTRFS_SUBVOLUME="NONE"
        fi
    fi
}

# create btrfs subvolume
create_btrfs_subvolume() {
    mount_btrfs
    btrfs subvolume create ${BTRFSMP}/${_btrfssubvolume} >${LOG}
    # change permission from 700 to 755 
    # to avoid warnings during package installation
    chmod 755 ${BTRFSMP}/${_btrfssubvolume}
    umount_btrfs
}

# choose btrfs subvolume from list
choose_btrfs_subvolume () {
    BTRFS_SUBVOLUME="NONE"
    SUBVOLUMES_DETECTED="no"
    SUBVOLUMES=$(find_btrfs_subvolume _)
    # check if subvolumes are present
    [[ -n "${SUBVOLUMES}" ]] && SUBVOLUMES_DETECTED="yes"
    subvolumes_in_use
    for i in ${SUBVOLUME_IN_USE}; do
        SUBVOLUMES=$(echo ${SUBVOLUMES} | sed -e "s#${i}\ _##g")
    done
    if [[ -n "${SUBVOLUMES}" ]]; then
        DIALOG --menu "Select the subvolume to mount" 21 50 13 ${SUBVOLUMES} 2>${ANSWER} || return 1
        BTRFS_SUBVOLUME=$(cat ${ANSWER})
    else
        if [[ "${SUBVOLUMES_DETECTED}" = "yes" ]]; then
            DIALOG --msgbox "ERROR: All subvolumes of the device are already in use. Switching to create a new one now." 8 65
            SKIP_ASK_SUBVOLUME=yes
            prepare_btrfs_subvolume || return 1
        fi
    fi
}

# boot on btrfs subvolume is not supported
check_btrfs_boot_subvolume() {
    if [[ "${MP}" = "/boot" && "${FSTYPE}" = "btrfs" && ! "${BTRFS_SUBVOLUME}" = "NONE" ]]; then
        DIALOG --msgbox "ERROR: \n/boot on a btrfs subvolume is not supported by any bootloader yet!" 8 65
        FILESYSTEM_FINISH="no"
    fi
}

# btrfs subvolume menu
btrfs_subvolume() {
    FILESYSTEM_FINISH=""
    if [[ "${FSTYPE}" = "btrfs" && "${DOMKFS}" = "no" ]]; then
        if [[ "${ASK_MOUNTPOINTS}" = "1" ]]; then
            # create subvolume if requested
            # choose btrfs subvolume if present
            prepare_btrfs_subvolume || return 1
            if [[ "${BTRFS_SUBVOLUME}" = "NONE" ]]; then
                choose_btrfs_subvolume || return 1
            fi
        else
            # use device if no subvolume is present
            choose_btrfs_subvolume || return 1
        fi
        btrfs_compress
        btrfs_ssd
    fi
    FILESYSTEM_FINISH="yes"
}

select_filesystem() {
    FILESYSTEM_FINISH=""
    # don't allow vfat as / filesystem, it will not work!
    # don't allow ntfs as / filesystem, this is stupid!
    FSOPTS=""
    [[ "$(which mkfs.ext2 2>/dev/null)" ]] && FSOPTS="${FSOPTS} ext2 Ext2"
    [[ "$(which mkfs.ext3 2>/dev/null)" ]] && FSOPTS="${FSOPTS} ext3 Ext3"
    [[ "$(which mkfs.ext4 2>/dev/null)" ]] && FSOPTS="${FSOPTS} ext4 Ext4"
    [[ "$(which mkfs.btrfs 2>/dev/null)" ]] && FSOPTS="${FSOPTS} btrfs Btrfs-(Experimental)"
    [[ "$(which mkfs.nilfs2 2>/dev/null)" ]] && FSOPTS="${FSOPTS} nilfs2 Nilfs2-(Experimental)"
    [[ "$(which mkreiserfs 2>/dev/null)" ]] && FSOPTS="${FSOPTS} reiserfs Reiser3"
    [[ "$(which mkfs.xfs 2>/dev/null)" ]] && FSOPTS="${FSOPTS} xfs XFS"
    [[ "$(which mkfs.jfs 2>/dev/null)" ]] && FSOPTS="${FSOPTS} jfs JFS"
    [[ "$(which mkfs.ntfs 2>/dev/null)" && "${DO_ROOT}" = "DONE" ]] && FSOPTS="${FSOPTS} ntfs-3g NTFS"
    [[ "$(which mkfs.vfat 2>/dev/null)" && "${DO_ROOT}" = "DONE" ]] && FSOPTS="${FSOPTS} vfat VFAT"
    DIALOG --menu "Select a filesystem for ${PART}" 21 50 13 ${FSOPTS} 2>${ANSWER} || return 1
    FSTYPE=$(cat ${ANSWER})
}

enter_mountpoint() {
    FILESYSTEM_FINISH=""
    MP=""
    while [[ "${MP}" = "" ]]; do
        DIALOG --inputbox "Enter the mountpoint for ${PART}" 8 65 "/boot" 2>${ANSWER} || return 1
        MP=$(cat ${ANSWER})
        if grep ":${MP}:" /tmp/.parts; then
            DIALOG --msgbox "ERROR: You have defined 2 identical mountpoints! Please select another mountpoint." 8 65
            MP=""
        fi
    done
}

# set sane values for paramaters, if not already set
check_mkfs_values() {
    # Set values, to not confuse mkfs call!
    [[ "${FS_OPTIONS}" = "" ]] && FS_OPTIONS="NONE"
    [[ "${BTRFS_DEVICES}" = "" ]] && BTRFS_DEVICES="NONE"
    [[ "${BTRFS_LEVEL}" = "" ]] && BTRFS_LEVEL="NONE"
    [[ "${BTRFS_SUBVOLUME}" = "" ]] && BTRFS_SUBVOLUME="NONE"
    [[ "${DOSUBVOLUME}" = "" ]] && DOSUBVOLUME="no"
    [[ "${LABEL_NAME}" = "" && -n "$(${_BLKID} -p -i -o value -s LABEL ${PART})" ]] && LABEL_NAME="$(${_BLKID} -p -i -o value -s LABEL ${PART})"
    [[ "${LABEL_NAME}" = "" ]] && LABEL_NAME="NONE"
}

create_filesystem() {
    FILESYSTEM_FINISH=""
    LABEL_NAME=""
    FS_OPTIONS=""
    BTRFS_DEVICES=""
    BTRFS_LEVEL=""
    DIALOG --yesno "Would you like to create a filesystem on ${PART}?\n\n(This will overwrite existing data!)" 0 0 && DOMKFS="yes"
    if [[ "${DOMKFS}" = "yes" ]]; then
        while [[ "${LABEL_NAME}" = "" ]]; do
            DIALOG --inputbox "Enter the LABEL name for the device, keep it short\n(not more than 12 characters) and use no spaces or special\ncharacters." 10 65 \
            "$(${_BLKID} -p -i -o value -s LABEL ${PART})" 2>${ANSWER} || return 1
            LABEL_NAME=$(cat ${ANSWER})
            if grep ":${LABEL_NAME}$" /tmp/.parts; then
                DIALOG --msgbox "ERROR: You have defined 2 identical LABEL names! Please enter another name." 8 65
                LABEL_NAME=""
            fi
        done
        if [[ "${FSTYPE}" = "btrfs" ]]; then
            prepare_btrfs || return 1
            btrfs_compress
            btrfs_ssd
        fi
        DIALOG --inputbox "Enter additional options to the filesystem creation utility.\nUse this field only, if the defaults are not matching your needs,\nelse just leave it empty." 10 70  2>${ANSWER} || return 1
        FS_OPTIONS=$(cat ${ANSWER})
    fi
    FILESYSTEM_FINISH="yes"
}

mountpoints() {
    NAME_SCHEME_PARAMETER_RUN=""
    while [[ "${PARTFINISH}" != "DONE" ]]; do
        activate_special_devices
        : >/tmp/.device-names
        : >/tmp/.fstab
        : >/tmp/.parts
        #
        # Select mountpoints
        #
        DIALOG --msgbox "Available partitions:\n\n$(_getavailpartitions)\n" 0 0
        PARTS=$(findpartitions _)
        DO_SWAP=""
        while [[ "${DO_SWAP}" != "DONE" ]]; do
            FSTYPE="swap"
            DIALOG --menu "Select the partition to use as swap" 21 50 13 NONE - ${PARTS} 2>${ANSWER} || return 1
            PART=$(cat ${ANSWER})
            if [[ "${PART}" != "NONE" ]]; then
                DOMKFS="no"
                if [[ "${ASK_MOUNTPOINTS}" = "1" ]]; then
                    create_filesystem
                else
                    FILESYSTEM_FINISH="yes"
                fi
            else
                FILESYSTEM_FINISH="yes"
            fi
            [[ "${FILESYSTEM_FINISH}" = "yes" ]] && DO_SWAP=DONE
        done
        check_mkfs_values
        if [[ "${PART}" != "NONE" ]]; then
            PARTS="$(echo ${PARTS} | sed -e "s#${PART}\ _##g")"
            echo "${PART}:swap:swap:${DOMKFS}:${LABEL_NAME}:${FS_OPTIONS}:${BTRFS_DEVICES}:${BTRFS_LEVEL}:${BTRFS_SUBVOLUME}:${DOSUBVOLUME}:${BTRFS_COMPRESS}:${BTRFS_SSD}" >>/tmp/.parts
        fi
        DO_ROOT=""
        while [[ "${DO_ROOT}" != "DONE" ]]; do
            DIALOG --menu "Select the partition to mount as /" 21 50 13 ${PARTS} 2>${ANSWER} || return 1
            PART=$(cat ${ANSWER})
            PART_ROOT=${PART}
            # Select root filesystem type
            FSTYPE="$(${_BLKID} -p -i -o value -s TYPE ${PART})"
            DOMKFS="no"
            # clear values first!
            clear_btrfs_values
            check_btrfs_filesystem_creation
            if [[ "${ASK_MOUNTPOINTS}" = "1" && "${SKIP_FILESYSTEM}" = "no" ]]; then
                select_filesystem && create_filesystem && btrfs_subvolume
            else                   
                btrfs_subvolume
            fi
            [[ "${FILESYSTEM_FINISH}" = "yes" ]] && DO_ROOT=DONE
        done
        find_btrfs_raid_devices
        btrfs_parts
        check_mkfs_values
        echo "${PART}:${FSTYPE}:/:${DOMKFS}:${LABEL_NAME}:${FS_OPTIONS}:${BTRFS_DEVICES}:${BTRFS_LEVEL}:${BTRFS_SUBVOLUME}:${DOSUBVOLUME}:${BTRFS_COMPRESS}:${BTRFS_SSD}" >>/tmp/.parts
        ! [[ "${FSTYPE}" = "btrfs" ]] && PARTS="$(echo ${PARTS} | sed -e "s#${PART}\ _##g")"
        #
        # Additional partitions
        #
        while [[ "${PART}" != "DONE" ]]; do
            DO_ADDITIONAL=""
            while [[ "${DO_ADDITIONAL}" != "DONE" ]]; do
                DIALOG --menu "Select any additional partitions to mount under your new root (select DONE when finished)" 21 52 13 ${PARTS} DONE _ 2>${ANSWER} || return 1
                PART=$(cat ${ANSWER})
                if [[ "${PART}" != "DONE" ]]; then
                    FSTYPE="$(${_BLKID} -p -i  -o value -s TYPE ${PART})"
                    DOMKFS="no"
                    # clear values first!
                    clear_btrfs_values
                    check_btrfs_filesystem_creation
                    # Select a filesystem type
                    if [[ "${ASK_MOUNTPOINTS}" = "1" && "${SKIP_FILESYSTEM}" = "no" ]]; then
                        enter_mountpoint && select_filesystem && create_filesystem && btrfs_subvolume
                    else
                        enter_mountpoint
                        btrfs_subvolume
                    fi
                    check_btrfs_boot_subvolume
                else
                    FILESYSTEM_FINISH="yes"
                fi
                [[ "${FILESYSTEM_FINISH}" = "yes" ]] && DO_ADDITIONAL="DONE"
            done
            if [[ "${PART}" != "DONE" ]]; then
                find_btrfs_raid_devices
                btrfs_parts
                check_mkfs_values
                echo "${PART}:${FSTYPE}:${MP}:${DOMKFS}:${LABEL_NAME}:${FS_OPTIONS}:${BTRFS_DEVICES}:${BTRFS_LEVEL}:${BTRFS_SUBVOLUME}:${DOSUBVOLUME}:${BTRFS_COMPRESS}:${BTRFS_SSD}" >>/tmp/.parts
                ! [[ "${FSTYPE}" = "btrfs" ]] && PARTS="$(echo ${PARTS} | sed -e "s#${PART}\ _##g")"
            fi
        done
        DIALOG --yesno "Would you like to create and mount the filesytems like this?\n\nSyntax\n------\nDEVICE:TYPE:MOUNTPOINT:FORMAT:LABEL:FSOPTIONS:BTRFS_DETAILS\n\n$(for i in $(cat /tmp/.parts | sed -e 's, ,#,g'); do echo "${i}\n";done)" 0 0 && PARTFINISH="DONE"
    done
    # disable swap and all mounted partitions
    _umountall
    if [[ "${NAME_SCHEME_PARAMETER_RUN}" = "" ]]; then
        set_device_name_scheme || return 1
    fi
    printk off
    for line in $(cat /tmp/.parts); do
        PART=$(echo ${line} | cut -d: -f 1)
        FSTYPE=$(echo ${line} | cut -d: -f 2)
        MP=$(echo ${line} | cut -d: -f 3)
        DOMKFS=$(echo ${line} | cut -d: -f 4)
        LABEL_NAME=$(echo ${line} | cut -d: -f 5)
        FS_OPTIONS=$(echo ${line} | cut -d: -f 6)
        BTRFS_DEVICES=$(echo ${line} | cut -d: -f 7)
        BTRFS_LEVEL=$(echo ${line} | cut -d: -f 8)
        BTRFS_SUBVOLUME=$(echo ${line} | cut -d: -f 9)
        DOSUBVOLUME=$(echo ${line} | cut -d: -f 10)
        BTRFS_COMPRESS=$(echo ${line} | cut -d: -f 11)
        BTRFS_SSD=$(echo ${line} | cut -d: -f 12)
        if [[ "${DOMKFS}" = "yes" ]]; then
            if [[ "${FSTYPE}" = "swap" ]]; then
                DIALOG --infobox "Creating and activating swapspace on ${PART}" 0 0
            else
                DIALOG --infobox "Creating ${FSTYPE} on ${PART},\nmounting to ${DESTDIR}${MP}" 0 0
            fi
            _mkfs yes ${PART} ${FSTYPE} ${DESTDIR} ${MP} ${LABEL_NAME} ${FS_OPTIONS} ${BTRFS_DEVICES} ${BTRFS_LEVEL} ${BTRFS_SUBVOLUME} ${DOSUBVOLUME} ${BTRFS_COMPRESS} ${BTRFS_SSD} || return 1
        else
            if [[ "${FSTYPE}" = "swap" ]]; then
                DIALOG --infobox "Activating swapspace on ${PART}" 0 0
            else
                DIALOG --infobox "Mounting ${FSTYPE} on ${PART} to ${DESTDIR}${MP}" 0 0
            fi
            _mkfs no ${PART} ${FSTYPE} ${DESTDIR} ${MP} ${LABEL_NAME} ${FS_OPTIONS} ${BTRFS_DEVICES} ${BTRFS_LEVEL} ${BTRFS_SUBVOLUME} ${DOSUBVOLUME} ${BTRFS_COMPRESS} ${BTRFS_SSD} || return 1
        fi
        sleep 1
    done
    printk on
    DIALOG --msgbox "Partitions were successfully mounted." 0 0
    NEXTITEM="5"
    S_MKFS=1
}

# _mkfs()
# Create and mount filesystems in our destination system directory.
#
# args:
#  domk: Whether to make the filesystem or use what is already there
#  device: Device filesystem is on
#  fstype: type of filesystem located at the device (or what to create)
#  dest: Mounting location for the destination system
#  mountpoint: Mount point inside the destination system, e.g. '/boot'

# returns: 1 on failure
_mkfs() {
    local _domk=${1}
    local _device=${2}
    local _fstype=${3}
    local _dest=${4}
    local _mountpoint=${5}
    local _labelname=${6}
    local _fsoptions=${7}
    local _btrfsdevices="$(echo ${8} | sed -e 's|#| |g')"
    local _btrfslevel=${9}
    local _btrfssubvolume=${10}
    local _dosubvolume=${11}
    local _btrfscompress=${12}
    local _btrfsssd=${13}
    # correct empty entries
    [[ "${_fsoptions}" = "NONE" ]] && _fsoptions=""
    [[ "${_btrfsssd}" = "NONE" ]] && _btrfsssd=""
    [[ "${_btrfscompress}" = "NONE" ]] && _btrfscompress=""
    [[ "${_btrfssubvolume}" = "NONE" ]] && _btrfssubvolume=""
    # add btrfs raid level, if needed
    [[ ! "${_btrfslevel}" = "NONE" && "${_fstype}" = "btrfs" ]] && _fsoptions="${_fsoptions} -d ${_btrfslevel}"
    # we have two main cases: "swap" and everything else.
    if [[ "${_fstype}" = "swap" ]]; then
        swapoff ${_device} >/dev/null 2>&1
        if [[ "${_domk}" = "yes" ]]; then
            mkswap -L ${_labelname} ${_device} >${LOG} 2>&1
            if [[ $? != 0 ]]; then
                DIALOG --msgbox "Error creating swap: mkswap ${_device}" 0 0
                return 1
            fi
        fi
        swapon ${_device} >${LOG} 2>&1
        if [[ $? != 0 ]]; then
            DIALOG --msgbox "Error activating swap: swapon ${_device}" 0 0
            return 1
        fi
    else
        # make sure the fstype is one we can handle
        local knownfs=0
        for fs in xfs jfs reiserfs ext2 ext3 ext4 btrfs nilfs2 ntfs-3g vfat; do
            [[ "${_fstype}" = "${fs}" ]] && knownfs=1 && break
        done
        if [[ ${knownfs} -eq 0 ]]; then
            DIALOG --msgbox "unknown fstype ${_fstype} for ${_device}" 0 0
            return 1
        fi
        # if we were tasked to create the filesystem, do so
        if [[ "${_domk}" = "yes" ]]; then
            local ret
            case ${_fstype} in
                xfs)      mkfs.xfs ${_fsoptions} -L ${_labelname} -f ${_device} >${LOG} 2>&1; ret=$? ;;
                jfs)      yes | mkfs.jfs ${_fsoptions} -L ${_labelname} ${_device} >${LOG} 2>&1; ret=$? ;;
                reiserfs) yes | mkreiserfs ${_fsoptions} -l ${_labelname} ${_device} >${LOG} 2>&1; ret=$? ;;
                ext2)     mkfs.ext2 -L ${_fsoptions} ${_labelname} ${_device} >${LOG} 2>&1; ret=$? ;;
                ext3)     mke2fs ${_fsoptions} -L ${_labelname} -t ext3 ${_device} >${LOG} 2>&1; ret=$? ;;
                ext4)     mke2fs ${_fsoptions} -L ${_labelname} -t ext4 ${_device} >${LOG} 2>&1; ret=$? ;;
                btrfs)    mkfs.btrfs ${_fsoptions} -L ${_labelname} ${_btrfsdevices} >${LOG} 2>&1; ret=$? ;;
                nilfs2)   mkfs.nilfs2 ${_fsoptions} -L ${_labelname} ${_device} >${LOG} 2>&1; ret=$? ;;
                ntfs-3g)  mkfs.ntfs ${_fsoptions} -L ${_labelname} ${_device} >${LOG} 2>&1; ret=$? ;;
                vfat)     mkfs.vfat ${_fsoptions} -n ${_labelname} ${_device} >${LOG} 2>&1; ret=$? ;;
                # don't handle anything else here, we will error later
            esac
            if [[ ${ret} != 0 ]]; then
                DIALOG --msgbox "Error creating filesystem ${_fstype} on ${_device}" 0 0
                return 1
            fi
            sleep 2
        fi
        if [[ "${_fstype}" = "btrfs" && -n "${_btrfssubvolume}" && "${_dosubvolume}" = "yes" ]]; then
            create_btrfs_subvolume
        fi
        btrfs_scan
        sleep 2
        # create our mount directory
        mkdir -p ${_dest}${_mountpoint}
        # prepare btrfs mount options
        _btrfsmountoptions=""
        [[ -n "${_btrfssubvolume}" ]] && _btrfsmountoptions="subvol=${_btrfssubvolume}"
        [[ -n "${_btrfscompress}" ]] && _btrfsmountoptions="${_btrfsmountoptions} ${_btrfscompress}"
        [[ -n "${_btrfsssd}" ]] && _btrfsmountoptions="${_btrfsmountoptions} ${_btrfsssd}"
        _btrfsmountoptions="$(echo ${_btrfsmountoptions} | sed -e 's#^ ##g' | sed -e 's# #,#g')"
        # mount the bad boy
        if [[ "${_fstype}" = "btrfs" && -n "${_btrfsmountoptions}" ]]; then
            mount -t ${_fstype} -o ${_btrfsmountoptions} ${_device} ${_dest}${_mountpoint} >${LOG} 2>&1
        else
            mount -t ${_fstype} ${_device} ${_dest}${_mountpoint} >${LOG} 2>&1
        fi
        if [[ $? != 0 ]]; then
            DIALOG --msgbox "Error mounting ${_dest}${_mountpoint}" 0 0
            return 1
        fi
        # change permission of base directories to correct permission
        # to avoid btrfs issues
        if [[ "${_mountpoint}" = "/tmp" ]]; then
            chmod 1777 ${_dest}${_mountpoint}
        elif [[ "${_mountpoint}" = "/root" ]]; then
            chmod 750 ${_dest}${_mountpoint}
        else
            chmod 755 ${_dest}${_mountpoint}
        fi
    fi
    # add to .device-names for config files
    local _fsuuid="$(getfsuuid ${_device})"
    local _fslabel="$(getfslabel ${_device})"
    echo "# DEVICE DETAILS: ${_device} UUID=${_fsuuid} LABEL=${_fslabel}" >> /tmp/.device-names
    # add to temp fstab
    if [[ "${NAME_SCHEME_PARAMETER}" == "FSUUID" ]]; then
        if [[ -n "${_fsuuid}" ]]; then
            _device="UUID=${_fsuuid}"
        fi
    elif [[ "${NAME_SCHEME_PARAMETER}" == "FSLABEL" ]]; then
        if [[ -n "${_fslabel}" ]]; then
            _device="LABEL=${_fslabel}"
        fi
    fi
    if [[ "${_fstype}" = "btrfs" && -n "${_btrfsmountoptions}" ]]; then
        echo -n "${_device} ${_mountpoint} ${_fstype} defaults,${_btrfsmountoptions} 0 " >>/tmp/.fstab
    else
        echo -n "${_device} ${_mountpoint} ${_fstype} defaults 0 " >>/tmp/.fstab
    fi
    if [[ "${_fstype}" = "swap" ]]; then
        echo "0" >>/tmp/.fstab
    else
        echo "1" >>/tmp/.fstab
    fi
}

getrootfstype() {
    ROOTFS="$(getfstype ${PART_ROOT})"
}

getrootflags() {
    # remove rw for all filesystems and gcpid for nilfs2
    ROOTFLAGS=""
    ROOTFLAGS="$(findmnt -m -n -o options -T ${DESTDIR} | sed -e 's/^rw//g' -e 's/,gcpid=.*[0-9]//g')"
    [[ -n "${ROOTFLAGS}" ]] && ROOTFLAGS="rootflags=${ROOTFLAGS}"
}

getraidarrays() {
    RAIDARRAYS=""
    if ! [[ "$(grep ^ARRAY ${DESTDIR}/etc/mdadm.conf)" ]]; then
        RAIDARRAYS="$(echo -n $(cat /proc/mdstat 2>/dev/null | grep ^md | sed -e 's#\[[0-9]\]##g' -e 's# :.* raid[0-9]##g' -e 's#md#md=#g' -e 's# #,/dev/#g' -e 's#_##g'))"
    fi
}

getcryptsetup() {
    CRYPTSETUP=""
    if ! [[ "$(cryptsetup status $(basename ${PART_ROOT}) | grep inactive)" ]]; then
        #avoid clash with dmraid here
        if [[ "$(cryptsetup status $(basename ${PART_ROOT}))" ]]; then
            if [[ "${NAME_SCHEME_PARAMETER}" == "FSUUID" ]]; then
                CRYPTDEVICE="UUID=$(echo $(${_BLKID} -p -i -s UUID -o value $(cryptsetup status $(basename ${PART_ROOT}) | grep device: | sed -e 's#device:##g')))"
            elif [[ "${NAME_SCHEME_PARAMETER}" == "FSLABEL" ]]; then
                CRYPTDEVICE="LABEL=$(echo $(${_BLKID} -p -i -s LABEL -o value $(cryptsetup status $(basename ${PART_ROOT}) | grep device: | sed -e 's#device:##g')))"
            else
                CRYPTDEVICE="$(echo $(cryptsetup status $(basename ${PART_ROOT}) | grep device: | sed -e 's#device:##g'))"    
            fi
            CRYPTNAME="$(basename ${PART_ROOT})"
            CRYPTSETUP="cryptdevice=${CRYPTDEVICE}:${CRYPTNAME}"
        fi
    fi
}

getrootfsuuid() {
    _rootpart="${PART_ROOT}"
    _fsuuid="$(getfsuuid ${PART_ROOT})"
    if [[ -n "${_fsuuid}" ]]; then
        _rootpart="UUID=${_fsuuid}"
    fi
}

getrootfslabel() {
    _rootpart="${PART_ROOT}"
    _fslabel="$(getfslabel ${PART_ROOT})"
    if [[ -n "${_fslabel}" ]]; then
        _rootpart="LABEL=${_fslabel}"
    fi
}

# basic checks needed for all bootloaders
common_bootloader_checks() {
    activate_special_devices
    getrootfstype
    getraidarrays
    getcryptsetup
    getrootflags
    [[ "${NAME_SCHEME_PARAMETER}" == "FSUUID" ]] && getrootfsuuid
    [[ "${NAME_SCHEME_PARAMETER}" == "FSLABEL" ]] && getrootfslabel
}

# look for a separately-mounted /boot partition
check_bootpart() {
    subdir=""
    bootdev="$(mount | grep "${DESTDIR}/boot " | cut -d' ' -f 1)"
    if [[ "${bootdev}" == "" ]]; then
        subdir="/boot"
        bootdev="${PART_ROOT}"
    fi
}

# check for btrfs bootpart and abort if detected
abort_btrfs_bootpart() {
        FSTYPE="$(${_BLKID} -p -i ${bootdev} -o value -s TYPE)"
        if [[ "${FSTYPE}" = "btrfs" ]]; then
            DIALOG --msgbox "Error:\nYour selected bootloader cannot boot from btrfs partition with /boot on it." 0 0
            return 1
        fi
}

# check for nilfs2 bootpart and abort if detected
abort_nilfs_bootpart() {
        FSTYPE="$(${_BLKID} -p -i ${bootdev} -o value -s TYPE)"
        if [[ "${FSTYPE}" = "nilfs2" ]]; then
            DIALOG --msgbox "Error:\nYour selected bootloader cannot boot from nilfs2 partition with /boot on it." 0 0
            return 1
        fi
}

do_uefi_common() {
    
    DISC="$(df -T "${DESTDIR}/boot" | tail -n +2 | awk '{print $1}' | sed 's/\(.\{8\}\).*/\1/')"
    
    if [[ "${DISC}" != "" ]]; then
        CHECK_UEFISYS_PART="1"
        CHECK_BIOS_BOOT_GRUB=""
        RUN_CGDISK=""
        # check_gpt
        check_uefisyspart
    fi
    
}

do_uefi_x86_64() {
    
    export _UEFI_ARCH="x86_64"
    export _SPEC_UEFI_ARCH="x64"
    
    do_uefi_common
    
}

do_uefi_i386() {
    
    export _UEFI_ARCH="i386"
    export _SPEC_UEFI_ARCH="ia32"
    
    do_uefi_common
    
}

do_uefi_efibootmgr() {
    
    modprobe -q efivars
    
    if [[ "$(lsmod | grep ^efivars)" ]]; then
        chroot_mount
        
        if [[ -d "${DESTDIR}/sys/firmware/efi/vars" ]]; then
            cat << EFIBEOF > "${DESTDIR}/efibootmgr_run.sh"
#!/usr/bin/env bash

for _bootnum in \$(efibootmgr | grep '^Boot[0-9]' | fgrep -i '${_EFIBOOTMGR_LABEL}' | cut -b5-8) ; do
    efibootmgr --bootnum "\${_bootnum}" --delete-bootnum
done

echo
efibootmgr --verbose --create --gpt --disk "${_EFIBOOTMGR_DISC}" --part "${_EFIBOOTMGR_PART_NUM}" --write-signature --label '${_EFIBOOTMGR_LABEL}' --loader '\\EFI\\${_EFIBOOTMGR_LOADER_DIR}\\${_EFIBOOTMGR_LOADER_FILE}'
echo

EFIBEOF
            
            chmod a+x "${DESTDIR}/efibootmgr_run.sh"
            chroot "${DESTDIR}" "/bin/bash" "/efibootmgr_run.sh" &>"/tmp/efibootmgr_run.log"
            mv "${DESTDIR}/efibootmgr_run.sh" "/tmp/efibootmgr_run.sh"
        else
            DIALOG --msgbox "${DESTDIR}/sys/firmware/efi/vars/ directory not found. Check whether you have booted in UEFI boot mode, manually load efivars kernel module and create a boot entry for ${_EFIBOOTMGR_LABEL} in the UEFI Boot Manager." 0 0
        fi
        
        chroot_umount
    else
        DIALOG --msgbox "efivars kernel module was not loaded properly. Manually load it and create a boot entry for DISC ${_EFIBOOTMGR_DISC} , PART ${_EFIBOOTMGR_PART_NUM} and LOADER \\EFI\\${_EFIBOOTMGR_LOADER_DIR}\\${_EFIBOOTMGR_LOADER_FILE} , in UEFI Boot Manager using efibootmgr." 0 0
    fi
    
    unset _EFIBOOTMGR_LABEL
    unset _EFIBOOTMGR_DISC
    unset _EFIBOOTMGR_PART_NUM
    unset _EFIBOOTMGR_LOADER_DIR
    unset _EFIBOOTMGR_LOADER_FILE
    
}

do_apple_efi_hfs_bless() {
    
    modprobe -q -r efivars || true
    
    ## Grub upstream bzr mactel branch => http://bzr.savannah.gnu.org/lh/grub/branches/mactel/changes
    ## Fedora's mactel-boot => https://bugzilla.redhat.com/show_bug.cgi?id=755093
    DIALOG --msgbox "TODO: Apple Mac EFI Bootloader Setup" 0 0
    
}

do_uefi_bootmgr_setup() {
    
    _uefisysdev="$(df -T "${DESTDIR}/boot/efi" | tail -n +2 | awk '{print $1}')"
    _DISC="$(echo "${_uefisysdev}" | sed 's/\(.\{8\}\).*/\1/')"
    UEFISYS_PART_NUM="$(${_BLKID} -p -i -s PART_ENTRY_NUMBER -o value "${_uefisysdev}")"
    
    _BOOTMGR_DISC="${_DISC}"
    _BOOTMGR_PART_NUM="${UEFISYS_PART_NUM}"
    
    if [[ "$(cat "/sys/class/dmi/id/sys_vendor")" == 'Apple Inc.' ]] || [[ "$(cat "/sys/class/dmi/id/sys_vendor")" == 'Apple Computer, Inc.' ]]; then
        do_apple_efi_hfs_bless
    else
        ## For all the non-Mac UEFI systems
        _EFIBOOTMGR_LABEL="${_BOOTMGR_LABEL}"
        _EFIBOOTMGR_DISC="${_BOOTMGR_DISC}"
        _EFIBOOTMGR_PART_NUM="${_BOOTMGR_PART_NUM}"
        _EFIBOOTMGR_LOADER_DIR="${_BOOTMGR_LOADER_DIR}"
        _EFIBOOTMGR_LOADER_FILE="${_BOOTMGR_LOADER_FILE}"
        do_uefi_efibootmgr
    fi
    
    unset _BOOTMGR_LABEL
    unset _BOOTMGR_DISC
    unset _BOOTMGR_PART_NUM
    unset _BOOTMGR_LOADER_DIR
    unset _BOOTMGR_LOADER_FILE
    
}

doefistub_uefi_common() {
    
    [[ "$(uname -m)" == "x86_64" ]] && __CARCH="x86_64"
    [[ "$(uname -m)" == "i686" ]] && __CARCH="i386"
    
    if [[ "${__CARCH}" != "${_UEFI_ARCH}" ]]; then
        DIALOG --msgbox "EFISTUB requires Kernel and UEFI arch to match, and requires CONFIG_EFI_STUB enabled kernel. Please install matching MANJARO Kernel and try again." 0 0
    elif [[ "${KERNELPKG}" == "linux-lts" ]]; then
        mkdir -p "${DESTDIR}/boot/efi/EFI/efilinux/"
        cp -f "${DESTDIR}/usr/lib/efilinux/efilinux${_SPEC_UEFI_ARCH}.efi" "${DESTDIR}/boot/efi/EFI/efilinux/efilinux${_SPEC_UEFI_ARCH}.efi"
        
        _EFILINUX="1"
        _CONTINUE="1"
    else
        _CONTINUE="1"
    fi
    
    if [[ "${_CONTINUE}" == "1" ]]; then
        bootdev=""
        grubdev=""
        complexuuid=""
        FAIL_COMPLEX=""
        USE_DMRAID=""
        RAID_ON_LVM=""
        common_bootloader_checks
        
        _EFISTUB_KERNEL="${VMLINUZ/linux/manjaro}.efi"
        [[ "${_EFILINUX}" == "1" ]] && _EFISTUB_KERNEL="${VMLINUZ/linux/manjaro}"
        _EFISTUB_INITRAMFS="${INITRAMFS/linux/manjaro}"
        
        mkdir -p "${DESTDIR}/boot/efi/EFI/manjaro/"
        
        rm -f "${DESTDIR}/boot/efi/EFI/manjaro/${_EFISTUB_KERNEL}"
        rm -f "${DESTDIR}/boot/efi/EFI/manjaro/${_EFISTUB_INITRAMFS}.img"
        rm -f "${DESTDIR}/boot/efi/EFI/manjaro/${_EFISTUB_INITRAMFS}-fallback.img"
        
        cp -f "${DESTDIR}/boot/${VMLINUZ}" "${DESTDIR}/boot/efi/EFI/manjaro/${_EFISTUB_KERNEL}"
        cp -f "${DESTDIR}/boot/${INITRAMFS}.img" "${DESTDIR}/boot/efi/EFI/manjaro/${_EFISTUB_INITRAMFS}.img"
        cp -f "${DESTDIR}/boot/${INITRAMFS}-fallback.img" "${DESTDIR}/boot/efi/EFI/manjaro/${_EFISTUB_INITRAMFS}-fallback.img"
        
        #######################
        
        cat << CONFEOF > "${DESTDIR}/etc/systemd/system/efistub_copy.path"
[Unit]
Description=Copy EFISTUB Kernel and Initramfs to UEFISYS Partition

[Path]
PathChanged=/boot/${INITRAMFS}-fallback.img
Unit=efistub_copy.service

[Install]
WantedBy=multi-user.target
CONFEOF
        
        cat << CONFEOF > "${DESTDIR}/etc/systemd/system/efistub_copy.service"
[Unit]
Description=Copy EFISTUB Kernel and Initramfs to UEFISYS Partition

[Service]
Type=oneshot
ExecStart=/bin/cp -f /boot/${VMLINUZ} /boot/efi/EFI/manjaro/${_EFISTUB_KERNEL}
ExecStart=/bin/cp -f /boot/${INITRAMFS}.img /boot/efi/EFI/manjaro/${_EFISTUB_INITRAMFS}.img
ExecStart=/bin/cp -f /boot/${INITRAMFS}-fallback.img /boot/efi/EFI/manjaro/${_EFISTUB_INITRAMFS}-fallback.img
CONFEOF
        
        chroot "${DESTDIR}" /usr/bin/systemctl enable efistub_copy.path
        
        if [[ "${SYSTEMD}" != "1" ]]; then
            
            cat << CONFEOF > "${DESTDIR}/usr/local/bin/efistub_copy.sh"
/bin/cp -f /boot/${VMLINUZ} /boot/efi/EFI/manjaro/${_EFISTUB_KERNEL}
/bin/cp -f /boot/${INITRAMFS}.img /boot/efi/EFI/manjaro/${_EFISTUB_INITRAMFS}.img
/bin/cp -f /boot/${INITRAMFS}-fallback.img /boot/efi/EFI/manjaro/${_EFISTUB_INITRAMFS}-fallback.img
CONFEOF
            
            cat << CONFEOF > "${DESTDIR}/etc/incron.d/efistub_copy.conf"
/boot/${INITRAMFS}-fallback.img IN_CLOSE_WRITE /usr/local/bin/efistub_copy.sh
CONFEOF
            
            DIALOG --msgbox "Add incrond to the DAEMONS list in /etc/rc.conf ." 0 0
        fi
        
        ###########################
        
        _bootdev="$(df -T "${DESTDIR}/boot" | tail -n +2 | awk '{print $1}')"
        _rootdev="$(df -T "${DESTDIR}/" | tail -n +2 | awk '{print $1}')"
        _uefisysdev="$(df -T "${DESTDIR}/boot/efi" | tail -n +2 | awk '{print $1}')"
        
        ROOT_PART_FS_UUID="$(getfsuuid "${_rootdev}")"
        ROOT_PART_FS_LABEL="$(getfslabel "${_rootdev}")"
        ROOT_PART_GPT_GUID="$(getpartuuid "${_rootdev}")"
        ROOT_PART_GPT_LABEL="$(getpartlabel "${_rootdev}")"
        
        getrootfstype
        
        UEFISYS_PART_FS_UUID="$(getfsuuid "${_uefisysdev}")"
        UEFISYS_PART_FS_LABEL="$(getfslabel "${_uefisysdev}")"
        UEFISYS_PART_GPT_GUID="$(getpartuuid "${_uefisysdev}")"
        UEFISYS_PART_GPT_LABEL="$(getpartlabel "${_uefisysdev}")"
        
        [[ "${NAME_SCHEME_PARAMETER}" == "FSUUID" ]] && _rootpart="UUID=${ROOT_PART_FS_UUID}"
        [[ "${NAME_SCHEME_PARAMETER}" == "PARTUUID" ]] && _rootpart="PARTUUID=${ROOT_PART_GPT_GUID}"
        [[ "${NAME_SCHEME_PARAMETER}" == "FSLABEL" ]] && _rootpart="LABEL=${ROOT_PART_FS_LABEL}"
        [[ "${NAME_SCHEME_PARAMETER}" == "PARTLABEL" ]] && _rootpart="PARTLABEL=${ROOT_PART_GPT_LABEL}"
        [[ "${_rootpart}" == "" ]] && _rootpart="${_rootdev}"
        
        ## TODO: All complex stuff like dmraid, cyptsetup etc. for kernel parameters - common_bootloader_checks ?
        _PARAMETERS_UNMOD="root=${_rootpart} ${ROOTFLAGS} rootfstype=${ROOTFS} ${RAIDARRAYS} ${CRYPTSETUP} ro initrd=\\EFI\\manjaro\\${_EFISTUB_INITRAMFS}.img"
        _PARAMETERS_MOD=$(echo "${_PARAMETERS_UNMOD}" | sed -e 's#   # #g' | sed -e 's#  # #g')
        
        if [[ "${_EFILINUX}" == "1" ]]; then
            cat << CONFEOF > "${DESTDIR}/boot/efi/EFI/efilinux/efilinux.cfg"
-f \\EFI\\manjaro\\${_EFISTUB_KERNEL} ${_PARAMETERS_MOD}
CONFEOF
        fi
        
        # cat << CONFEOF > "${DESTDIR}/boot/efi/EFI/manjaro/linux.conf"
# ${_PARAMETERS_MOD}
# CONFEOF
        
        ###################################
        
        if [[ -e "${DESTDIR}/boot/efi/EFI/manjaro/${_EFISTUB_KERNEL}" ]] && [[ -e "${DESTDIR}/boot/efi/EFI/manjaro/${_EFISTUB_INITRAMFS}.img" ]]; then
            DIALOG --msgbox "The EFISTUB Kernel and initramfs have been copied to /boot/efi/EFI/manjaro/${_EFISTUB_KERNEL} and /boot/efi/EFI/manjaro/${_EFISTUB_INITRAMFS}.img respectively." 0 0
            
            if [[ "${_EFILINUX}" == "1" ]]; then
                DIALOG --msgbox "You will now be put into the editor to edit efilinux.cfg . After you save your changes, exit the editor." 0 0
                geteditor || return 1
                "${EDITOR}" "${DESTDIR}/boot/efi/EFI/efilinux/efilinux.cfg"
            # else
                # _BOOTMGR_LABEL="Manjaro Linux (EFISTUB)"
                # _BOOTMGR_LOADER_DIR="manjaro"
                # _BOOTMGR_LOADER_FILE="${_EFISTUB_KERNEL}"
                # do_uefi_bootmgr_setup
                
                # DIALOG --msgbox "You will now be put into the editor to edit linux.conf . After you save your changes, exit the editor." 0 0
                # geteditor || return 1
                # "${EDITOR}" "${DESTDIR}/boot/efi/EFI/manjaro/linux.conf"
                
                # DIALOG --defaultno --yesno "Do you want to copy /boot/efi/EFI/manjaro/${_EFISTUB_KERNEL} to /boot/efi/EFI/boot/boot${_SPEC_UEFI_ARCH}.efi .\n\nThis might be needed in some systems where efibootmgr may not work due to firmware issues." 0 0 && _UEFISYS_EFI_BOOT_DIR="1"
                
                # if [[ "${_UEFISYS_EFI_BOOT_DIR}" == "1" ]]; then
                    # mkdir -p "${DESTDIR}/boot/efi/EFI/boot"
                    
                    # rm -f "${DESTDIR}/boot/efi/EFI/boot/boot${_SPEC_UEFI_ARCH}.efi"
                    # rm -f "${DESTDIR}/boot/efi/EFI/boot/linux.conf"
                    
                    # cp -f "${DESTDIR}/boot/efi/EFI/manjaro/${_EFISTUB_KERNEL}" "${DESTDIR}/boot/efi/EFI/boot/boot${_SPEC_UEFI_ARCH}.efi"
                    # cp -f "${DESTDIR}/boot/efi/EFI/boot/linux.conf" "${DESTDIR}/boot/efi/EFI/boot/linux.conf"
                # fi
            fi
            
            DIALOG --menu "Select which UEFI Boot Manager to install, to provide a menu for EFISTUB kernels?" 13 55 3 \
                "GUMMIBOOT_UEFI_${UEFI_ARCH}" "Simple Text Mode ${UEFI_ARCH} UEFI Boot Manager" \
                "rEFInd_UEFI_${UEFI_ARCH}" "rEFInd ${UEFI_ARCH} UEFI Boot Manager" \
                "NONE" "No Boot Manager" 2>${ANSWER} || CANCEL=1
            case $(cat ${ANSWER}) in
                "GUMMIBOOT_UEFI_${UEFI_ARCH}") dogummiboot_uefi_common ;;
                "rEFInd_UEFI_${UEFI_ARCH}") dorefind_uefi_common ;;
                "NONE") return 0 ;;
            esac
        else
            DIALOG --msgbox "Error setting up EFISTUB kernel and initramfs in /boot/efi." 0 0
        fi
    fi
    
}

do_efistub_uefi_x86_64() {
    
    do_uefi_x86_64
    
    doefistub_uefi_common
    
}

do_efistub_uefi_i686() {
    
    do_uefi_i386
    
    doefistub_uefi_common
    
}

dogummiboot_uefi_common() {
    
    DIALOG --msgbox "Setting up gummiboot-efi now ..." 0 0
    
    mkdir -p "${DESTDIR}/boot/efi/EFI/gummiboot/"
    cp -f "${DESTDIR}/usr/lib/gummiboot/gummiboot${_SPEC_UEFI_ARCH}.efi" "${DESTDIR}/boot/efi/EFI/gummiboot/gummiboot${_SPEC_UEFI_ARCH}.efi"
    
    if [[ "${_EFILINUX}" == "1" ]]; then
        cat << GUMEOF > "${DESTDIR}/boot/efi/loader/entries/manjaro-lts.conf"
title   Manjaro Linux LTS via EFILINUX
efi     /EFI/efilinux/efilinux${_SPEC_UEFI_ARCH}.efi
options $(cat "${DESTDIR}/boot/efi/EFI/efilinux/efilinux.cfg")
GUMEOF
        
        cat << GUMEOF > "${DESTDIR}/boot/efi/loader/entries/manjaro-lts-fallback.conf"
title   Manjaro Linux LTS via EFILINUX  - fallback initramfs
efi     /EFI/efilinux/efilinux${_SPEC_UEFI_ARCH}.efi
options $(cat "${DESTDIR}/boot/efi/EFI/efilinux/efilinux.cfg") initrd=\\EFI\\manjaro\\${_EFISTUB_INITRAMFS}-fallback.img
GUMEOF
        
        cat << GUMEOF > "${DESTDIR}/boot/efi/loader/loader.conf"
timeout 3
default manjaro-lts
GUMEOF
        
    else
        cat << GUMEOF > "${DESTDIR}/boot/efi/loader/entries/manjaro.conf"
title   Manjaro Linux
linux   /EFI/manjaro/${_EFISTUB_KERNEL}
initrd  /EFI/manjaro/${_EFISTUB_INITRAMFS}.img
options ${_PARAMETERS_MOD}
GUMEOF
        
        cat << GUMEOF > "${DESTDIR}/boot/efi/loader/entries/manjaro-fallback.conf"
title   Manjaro Linux fallback initramfs
linux   /EFI/manjaro/${_EFISTUB_KERNEL}
initrd  /EFI/manjaro/${_EFISTUB_INITRAMFS}-fallback.img
options ${_PARAMETERS_MOD}
GUMEOF
        
        cat << GUMEOF > "${DESTDIR}/boot/efi/loader/loader.conf"
timeout 3
default manjaro
GUMEOF
        
    fi
    
    if [[ -e "${DESTDIR}/boot/efi/EFIgummiboot/gummiboot${_SPEC_UEFI_ARCH}.efi" ]]; then
        _BOOTMGR_LABEL="Manjaro Linux (gummiboot)"
        _BOOTMGR_LOADER_DIR="gummiboot"
        _BOOTMGR_LOADER_FILE="gummiboot${_SPEC_UEFI_ARCH}.efi"
        do_uefi_bootmgr_setup
        
        DIALOG --msgbox "gummiboot-efi has been setup successfully." 0 0
        
        DIALOG --msgbox "You will now be put into the editor to edit loader.conf and gummiboot menu entry files . After you save your changes, exit the editor." 0 0
        geteditor || return 1
        
        if [[ "${_EFILINUX}" == "1" ]]; then
            "${EDITOR}" "${DESTDIR}/boot/efi/loader/entries/manjaro-lts.conf"
            "${EDITOR}" "${DESTDIR}/boot/efi/loader/entries/manjaro-lts-fallback.conf"
        else
            "${EDITOR}" "${DESTDIR}/boot/efi/loader/entries/manjaro.conf"
            "${EDITOR}" "${DESTDIR}/boot/efi/loader/entries/manjaro-fallback.conf"
        fi
        
        "${EDITOR}" "${DESTDIR}/boot/efi/loader/loader.conf"
        
        DIALOG --defaultno --yesno "Do you want to copy /boot/efi/EFI/gummiboot/gummiboot${_SPEC_UEFI_ARCH}.efi to /boot/efi/EFI/boot/boot${_SPEC_UEFI_ARCH}.efi ?\n\nThis might be needed in some systems where efibootmgr may not work due to firmware issues." 0 0 && _UEFISYS_EFI_BOOT_DIR="1"
        
        if [[ "${_UEFISYS_EFI_BOOT_DIR}" == "1" ]]; then
            mkdir -p "${DESTDIR}/boot/efi/EFI/boot"
            rm -f "${DESTDIR}/boot/efi/EFI/boot/boot${_SPEC_UEFI_ARCH}.efi"
            cp -f "${DESTDIR}/boot/efi/EFI/gummiboot/gummiboot${_SPEC_UEFI_ARCH}.efi" "${DESTDIR}/boot/efi/EFI/boot/boot${_SPEC_UEFI_ARCH}.efi"
        fi
    else
        DIALOG --msgbox "Error setting up gummiboot-efi." 0 0
    fi
    
}

dorefind_uefi_common() {
    
    DIALOG --msgbox "Setting up refind-efi now ..." 0 0
    
    mkdir -p "${DESTDIR}/boot/efi/EFI/refind/"
    cp -f "${DESTDIR}/usr/lib/refind/refind${_SPEC_UEFI_ARCH}.efi" "${DESTDIR}/boot/efi/EFI/refind/refind${_SPEC_UEFI_ARCH}.efi"
    cp -r "${DESTDIR}/usr/share/refind/icons" "${DESTDIR}/boot/efi/EFI/refind/icons"
    
    _REFIND_CONFIG="${DESTDIR}/boot/efi/EFI/refind/refind.conf"
    cp -f "${DESTDIR}/usr/lib/refind/config/refind.conf" "${_REFIND_CONFIG}"

    sed 's|^timeout 20|timeout 0|g' -i "${_REFIND_CONFIG}"
    sed 's|^#resolution 1024 768|resolution 1024 768|g' -i "${_REFIND_CONFIG}"
    sed 's|^#showtools shell, about, reboot|showtools shell, about, exit, shutdown, reboot|g' -i "${_REFIND_CONFIG}"
    sed 's|^#scan_driver_dirs EFI/tools/drivers,drivers|scan_driver_dirs EFI/tools/drivers|g' -i "${_REFIND_CONFIG}"
    sed 's|^#scanfor internal,external,optical|scanfor internal,external,optical,manual|g' -i "${_REFIND_CONFIG}"
    sed 's|^#dont_scan_dirs EFI/boot|dont_scan_dirs EFI/boot|g' -i "${_REFIND_CONFIG}"
    sed 's|^#max_tags 0|max_tags 0|g' -i "${_REFIND_CONFIG}"
    
    if [[ "${_EFILINUX}" == "1" ]]; then
        cat << REFINDEOF >> "${_REFIND_CONFIG}"

menuentry "Manjaro Linux LTS via EFILINUX" {
	icon /EFI/refind/icons/os_linux.icns
	loader /EFI/efilinux/efilinux${_SPEC_UEFI_ARCH}.efi
	options "$(cat "${DESTDIR}/boot/efi/EFI/efilinux/efilinux.cfg")"
}

menuentry "Manjaro Linux LTS via EFILINUX - fallback initramfs" {
	icon /EFI/refind/icons/os_linux.icns
	loader /EFI/efilinux/efilinux${_SPEC_UEFI_ARCH}.efi
	options "$(cat "${DESTDIR}/boot/efi/EFI/efilinux/efilinux.cfg") initrd=\\EFI\\manjaro\\${_EFISTUB_INITRAMFS}-fallback.img"
}

REFINDEOF
        
    else
        cat << REFINDEOF > "${DESTDIR}/boot/efi/EFI/manjaro/refind_linux.conf"
"Boot with Defaults"              "${_PARAMETERS_MOD}"
"Boot with fallback initramfs"    "${_PARAMETERS_MOD} initrd=\\EFI\\manjaro\\${_EFISTUB_INITRAMFS}-fallback.img"
REFINDEOF
        
    fi
    
    if [[ -e "${DESTDIR}/boot/efi/EFI/refind/refind${_SPEC_UEFI_ARCH}.efi" ]]; then
        _BOOTMGR_LABEL="Manjaro Linux (rEFInd)"
        _BOOTMGR_LOADER_DIR="refind"
        _BOOTMGR_LOADER_FILE="refind${_SPEC_UEFI_ARCH}.efi"
        do_uefi_bootmgr_setup
        
        DIALOG --msgbox "refind-efi has been setup successfully." 0 0
        
        DIALOG --msgbox "You will now be put into the editor to edit refind.conf (and maybe refind_linux.conf) . After you save your changes, exit the editor." 0 0
        geteditor || return 1
        "${EDITOR}" "${_REFIND_CONFIG}"
        [[ "${_EFILINUX}" != "1" ]] && "${EDITOR}" "${DESTDIR}/boot/efi/EFI/manjaro/refind_linux.conf"
        
        DIALOG --defaultno --yesno "Do you want to copy /boot/efi/EFI/refind/refind${_SPEC_UEFI_ARCH}.efi to /boot/efi/EFI/boot/boot${_SPEC_UEFI_ARCH}.efi ?\n\nThis might be needed in some systems where efibootmgr may not work due to firmware issues." 0 0 && _UEFISYS_EFI_BOOT_DIR="1"
        
        if [[ "${_UEFISYS_EFI_BOOT_DIR}" == "1" ]]; then
            mkdir -p "${DESTDIR}/boot/efi/EFI/boot"
            
            rm -f "${DESTDIR}/boot/efi/EFI/boot/boot${_SPEC_UEFI_ARCH}.efi"
            rm -f "${DESTDIR}/boot/efi/EFI/boot/refind.conf"
            rm -rf "${DESTDIR}/boot/efi/EFI/boot/icons"
            
            cp -f "${DESTDIR}/boot/efi/EFI/refind/refind${_SPEC_UEFI_ARCH}.efi" "${DESTDIR}/boot/efi/EFI/boot/boot${_SPEC_UEFI_ARCH}.efi"
            cp -f "${_REFIND_CONFIG}" "${DESTDIR}/boot/efi/EFI/boot/refind.conf"
            cp -rf "${DESTDIR}/boot/efi/EFI/refind/icons" "${DESTDIR}/boot/efi/EFI/boot/icons"
        fi
    else
        DIALOG --msgbox "Error setting up refind-efi." 0 0
    fi
    
}

# install syslinux and run preparation
prepare_syslinux() {
    USE_DMRAID=""
    common_bootloader_checks
}

# common syslinux funtion
common_syslinux() {
    DEVS="$(findbootloaderdisks _)"
    DEVS="${DEVS} $(findbootloaderpartitions _)"
    
    if [[ "${DEVS}" == "" ]]; then
        DIALOG --msgbox "No hard drives were found" 0 0
        return 1
    fi
    
    DIALOG --menu "Select the boot device where the ${SYSLINUX} bootloader will be installed (usually the MBR)" 14 55 7 ${DEVS} 2>${ANSWER} || return 1
    ROOTDEV=$(cat ${ANSWER})
    
    # generate config file
    TEMPDIR=/tmp
    
    # check if GPT/GUID is used
    GUID_DETECTED=""
    [[ "$(${_BLKID} -p -i -o value -s PTTYPE ${ROOTDEV})" == "gpt" ]] && GUID_DETECTED="1"
    
    PARTITION_NUMBER=$(echo ${bootdev} | sed -e 's#.*[a-z]##g')
    if [[ "${GUID_DETECTED}" == '1' ]]; then
        # Set Legacy BIOS Bootable GPT Partition Attribute using sgdisk
        if ! [[ "$(sgdisk -i ${PARTITION_NUMBER} ${ROOTDEV} | grep '^Attribute' | grep '4$')" ]]; then
            sgdisk ${ROOTDEV} --attributes=${PARTITION_NUMBER}:set:2
        fi
    else
        # mark the partition with /boot as active in MBR
        parted -s ${ROOTDEV} set ${PARTITION_NUMBER} boot on >${LOG}
    fi
    
    [[ -e "${TEMPDIR}/${SYSLINUX_CONF}" ]] && rm -f "${TEMPDIR}/${SYSLINUX_CONF}"
    
    cat << EOF > "${TEMPDIR}/${SYSLINUX_CONF}"
DEFAULT vesamenu.c32
PROMPT 0
MENU TITLE Manjaro Linux
MENU BACKGROUND ${subdir}/${SYSLINUX_DIR}/splash.png
TIMEOUT 300

MENU WIDTH 78
MENU MARGIN 4
MENU ROWS 10
MENU VSHIFT 10
MENU TIMEOUTROW 15
MENU TABMSGROW 13
MENU CMDLINEROW 11
MENU HELPMSGROW 17
MENU HELPMSGENDROW 29

# Refer to http://syslinux.zytor.com/wiki/index.php/Doc/menu

MENU COLOR border       30;44   #40ffffff #a0000000 std
MENU COLOR title        1;36;44 #9033ccff #a0000000 std
MENU COLOR sel          7;37;40 #e0ffffff #20ffffff all
MENU COLOR unsel        37;44   #50ffffff #a0000000 std
MENU COLOR help         37;40   #c0ffffff #a0000000 std
MENU COLOR timeout_msg  37;40   #80ffffff #00000000 std
MENU COLOR timeout      1;37;40 #c0ffffff #00000000 std
MENU COLOR msg07        37;40   #90ffffff #a0000000 std
MENU COLOR tabmsg       31;40   #30ffffff #00000000 std

ONTIMEOUT manjaro
EOF
    sort /tmp/.device-names >> "${TEMPDIR}/${SYSLINUX_CONF}"
    echo "label manjaro" >> "${TEMPDIR}/${SYSLINUX_CONF}"
    echo "TEXT HELP" >> "${TEMPDIR}/${SYSLINUX_CONF}"
    echo "Boot Manjaro Linux" >> "${TEMPDIR}/${SYSLINUX_CONF}"
    echo "ENDTEXT" >> "${TEMPDIR}/${SYSLINUX_CONF}"
    echo "MENU LABEL Manjaro Linux" >> "${TEMPDIR}/${SYSLINUX_CONF}"
    echo "LINUX ${subdir}/${VMLINUZ}" >> "${TEMPDIR}/${SYSLINUX_CONF}"
    
    if [[ "${NAME_SCHEME_PARAMETER}" == "FSUUID" || "${NAME_SCHEME_PARAMETER}" == "FSLABEL" ]]; then
        echo "append initrd=${subdir}/${INITRAMFS}.img root=${_rootpart} ${ROOTFLAGS} rootfstype=${ROOTFS} ${RAIDARRAYS} ${CRYPTSETUP} ro" | sed -e 's#  # #g' >> "${TEMPDIR}/${SYSLINUX_CONF}"
    else
        echo "append initrd=${subdir}/${INITRAMFS}.img root=${PART_ROOT} ${ROOTFLAGS} rootfstype=${ROOTFS} ${RAIDARRAYS} ${CRYPTSETUP} ro" | sed -e 's#  # #g' >> "${TEMPDIR}/${SYSLINUX_CONF}"
    fi
    
    echo "label fallback" >> "${TEMPDIR}/${SYSLINUX_CONF}"
    echo "TEXT HELP" >> "${TEMPDIR}/${SYSLINUX_CONF}"
    echo "Boot Manjaro Linux Fallback" >> "${TEMPDIR}/${SYSLINUX_CONF}"
    echo "ENDTEXT" >> "${TEMPDIR}/${SYSLINUX_CONF}"
    echo "MENU LABEL Manjaro Linux Fallback" >> "${TEMPDIR}/${SYSLINUX_CONF}"
    echo "LINUX ${subdir}/${VMLINUZ}" >> "${TEMPDIR}/${SYSLINUX_CONF}"
    
    if [[ "${NAME_SCHEME_PARAMETER}" == "FSUUID" || "${NAME_SCHEME_PARAMETER}" == "FSLABEL" ]]; then
        echo "append initrd=${subdir}/${INITRAMFS}-fallback.img root=${_rootpart} ${ROOTFLAGS} rootfstype=${ROOTFS} ${RAIDARRAYS} ${CRYPTSETUP}" | sed -e 's#  # #g' >> "${TEMPDIR}/${SYSLINUX_CONF}"
    else
        echo "append initrd=${subdir}/${INITRAMFS}-fallback.img root=${PART_ROOT} ${ROOTFLAGS} rootfstype=${ROOTFS} ${RAIDARRAYS} ${CRYPTSETUP}" | sed -e 's#  # #g' >> "${TEMPDIR}/${SYSLINUX_CONF}"
    fi
    
    # edit config file
    DIALOG --msgbox "Before installing ${SYSLINUX}, you must review the configuration file.  You will now be put into the editor.  After you save your changes and exit the editor, ${SYSLINUX} will be installed." 0 0
    geteditor || return 1
    "${EDITOR}" "${TEMPDIR}/${SYSLINUX_CONF}"
    
    # install syslinux
    DIALOG --infobox "Installing the ${SYSLINUX} bootloader..." 0 0
    ! [[ -d "${DESTDIR}/boot/${SYSLINUX_DIR}" ]] && mkdir -p "${DESTDIR}/boot/${SYSLINUX_DIR}"
    cp -f "${TEMPDIR}/${SYSLINUX_CONF}" "${DESTDIR}/boot/${SYSLINUX_DIR}/${SYSLINUX_CONF}"
    cp -f "${DESTDIR}/usr/lib/syslinux"/*.c32 "${DESTDIR}/boot/${SYSLINUX_DIR}"
}

# finish_syslinux
finish_syslinux () {
    MBR="${DESTDIR}/usr/lib/syslinux/mbr.bin"
    GPTMBR="${DESTDIR}/usr/lib/syslinux/gptmbr.bin"
    
    CHECKDEV=$(echo ${ROOTDEV} | sed 's|/dev/||g')
    
    ## Install MBR boot code only if the selected ROOTDEV is a DISC and not a partition
    if [[ -e "${block}/${CHECKDEV}" ]]; then
        ## check if GPT/GUID is used
        GUID_DETECTED=""
        [[ "$(${_BLKID} -p -i -o value -s PTTYPE ${ROOTDEV})" == "gpt" ]] && GUID_DETECTED="1"
        
        if [[ "${GUID_DETECTED}" == '1' ]]; then
            cat "${GPTMBR}" > "${ROOTDEV}"
        else
            cat "${MBR}" > "${ROOTDEV}"
        fi
    fi
    
    [[ -f "${_MEDIA}/boot/syslinux/splash.png" ]] && cp -f "${_MEDIA}/boot/syslinux/splash.png" "${DESTDIR}/boot/${SYSLINUX_DIR}"
    chroot_umount
    
    if [[ -e "${DESTDIR}/boot/${SYSLINUX_DIR}/ldlinux.sys" ]]; then
        DIALOG --msgbox "${SYSLINUX} was successfully installed." 0 0
    else
        DIALOG --msgbox "Error installing ${SYSLINUX}. (see ${LOG} for output)" 0 0
        chroot_umount
        return 1
    fi
}

# install extlinux bootloader
dosyslinux_bios () {
    bootdev=""
    SYSLINUX_PACKAGES="syslinux"
    SYSLINUX=EXTLINUX
    SYSLINUX_PROGRAM=extlinux
    SYSLINUX_DIR=syslinux
    SYSLINUX_CONF=syslinux.cfg
    SYSLINUX_OPTS=""
    
    prepare_syslinux
    check_bootpart
    abort_nilfs_bootpart || return 1
    
    # extlinux only can boot from ext2/3/4 and btrfs partitions!
    FSTYPE="$(${_BLKID} -p -i -o value -s TYPE ${bootdev})"
    if ! [[ "${FSTYPE}" == "ext2" || "${FSTYPE}" == "ext3" || "${FSTYPE}" == "ext4" || "${FSTYPE}" == "btrfs" || "${FSTYPE}" == "vfat" ]]; then
        DIALOG --msgbox "Error:\nCouldn't find ext2/3/4 , btrfs or vfat partition with /boot on it." 0 0
        return 1
    fi
    
    # extlinux cannot boot from any raid partition, encrypted and dmraid device
    if [[ "$(echo ${bootdev} | grep /dev/md*p)" || "$(echo ${bootdev} | grep /dev/mapper)" ]]; then
        DIALOG --msgbox "Error:\n${SYSLINUX} cannot boot from any raid partition, encrypted or dmraid device." 0 0
        return 1
    fi
    
    # check if raid1 device is used, else fail.
    if [[ "$(echo ${bootdev} | grep /dev/md)" ]]; then
        if ! [[ "$(mdadm --detail ${bootdev} | grep Level | sed -e 's#.*:\ ##g')" = "raid1" ]]; then
            DIALOG --msgbox "Error:\n${SYSLINUX} cannot boot from non raid1 devices." 0 0
            return 1
        else
            SYSLINUX_OPTS="--raid"
        fi
    fi
    
    # extlinux cannot boot from btrfs raid
    find_btrfs_raid_bootloader_devices
    if [[ ${BTRFS_COUNT} -ge 3 ]]; then
        DIALOG --msgbox "Error:\n${SYSLINUX} cannot boot from any btrfs raid." 0 0
        return 1
    fi
    
    # extlinux cannot boot from btrfs subvolume
    find_btrfs_bootloader_subvolume
    if [[ ${BTRFS_SUBVOLUME_COUNT} -ge 3 ]]; then
        DIALOG --msgbox "Error:\n${SYSLINUX} cannot boot from btrfs subvolume." 0 0
        return 1
    fi
    
    common_syslinux
    chroot_mount
    chroot ${DESTDIR} ${SYSLINUX_PROGRAM} ${SYSLINUX_OPTS} --install /boot/${SYSLINUX_DIR} >${LOG} 2>&1
    finish_syslinux
}

dogrub_common_before() {
    ##### Check whether the below limitations still continue with ver 2.00~beta4
    ### Grub(2) restrictions:
    # - Encryption is not recommended for grub(2) /boot!
    
    bootdev=""
    grubdev=""
    complexuuid=""
    FAIL_COMPLEX=""
    USE_DMRAID=""
    RAID_ON_LVM=""
    common_bootloader_checks
    
    if ! [[ "$(dmraid -r | grep ^no )" ]]; then
        DIALOG --yesno "Setup detected dmraid device.\nDo you want to install grub on this device?" 0 0 && USE_DMRAID="1"
    fi
}

dogrub_mkconfig() {
    chroot_mount

    # prepare grub.cfg
    chroot ${DESTDIR} mkdir -p /boot/grub/locale
    chroot ${DESTDIR} cp /usr/share/locale/en@quot/LC_MESSAGES/grub.mo /boot/grub/locale/en.mo

    # create grub.cfg
    chroot ${DESTDIR} grub-mkconfig -o "/${GRUB_PREFIX_DIR}/grub.cfg" >> /tmp/grub.log 2>&1

    chroot_umount
}

dogrub_config() {

    ########
    
    BOOT_PART_FS_UUID="$(LD_LIBRARY_PATH="${DESTDIR}/usr/lib:${DESTDIR}/lib" "${DESTDIR}/usr/sbin/grub-probe" --target="fs_uuid" "${DESTDIR}/boot" 2>/dev/null)"
    BOOT_PART_FS="$(LD_LIBRARY_PATH="${DESTDIR}/usr/lib:${DESTDIR}/lib" "${DESTDIR}/usr/sbin/grub-probe" --target="fs" "${DESTDIR}/boot" 2>/dev/null)"
    
    BOOT_PART_FS_LABEL="$(LD_LIBRARY_PATH="${DESTDIR}/usr/lib:${DESTDIR}/lib" "${DESTDIR}/usr/sbin/grub-probe" --target="fs_label" "${DESTDIR}/boot" 2>/dev/null)"
    BOOT_PART_DRIVE="$(LD_LIBRARY_PATH="${DESTDIR}/usr/lib:${DESTDIR}/lib" "${DESTDIR}/usr/sbin/grub-probe" --target="drive" "${DESTDIR}/boot" 2>/dev/null)"
    
    BOOT_PART_HINTS_STRING="$(LD_LIBRARY_PATH="${DESTDIR}/usr/lib:${DESTDIR}/lib" "${DESTDIR}/usr/sbin/grub-probe" --target="hints_string" "${DESTDIR}/boot" 2>/dev/null)"
    
    ########
    
    ROOT_PART_FS_UUID="$(LD_LIBRARY_PATH="${DESTDIR}/usr/lib:${DESTDIR}/lib" "${DESTDIR}/usr/sbin/grub-probe" --target="fs_uuid" "${DESTDIR}/" 2>/dev/null)"
    ROOT_PART_FS="$(LD_LIBRARY_PATH="${DESTDIR}/usr/lib:${DESTDIR}/lib" "${DESTDIR}/usr/sbin/grub-probe" --target="fs" "${DESTDIR}/" 2>/dev/null)"
    
    ROOT_PART_FS_LABEL="$(LD_LIBRARY_PATH="${DESTDIR}/usr/lib:${DESTDIR}/lib" "${DESTDIR}/usr/sbin/grub-probe" --target="fs_label" "${DESTDIR}/" 2>/dev/null)"
    ROOT_PART_DEVICE="$(LD_LIBRARY_PATH="${DESTDIR}/usr/lib:${DESTDIR}/lib" "${DESTDIR}/usr/sbin/grub-probe" --target="device" "${DESTDIR}/" 2>/dev/null)"
    
    ROOT_PART_HINTS_STRING="$(LD_LIBRARY_PATH="${DESTDIR}/usr/lib:${DESTDIR}/lib" "${DESTDIR}/usr/sbin/grub-probe" --target="hints_string" "${DESTDIR}/" 2>/dev/null)"
    
    ########
    
    USR_PART_FS_UUID="$(LD_LIBRARY_PATH="${DESTDIR}/usr/lib:${DESTDIR}/lib" "${DESTDIR}/usr/sbin/grub-probe" --target="fs_uuid" "${DESTDIR}/usr" 2>/dev/null)"
    USR_PART_FS="$(LD_LIBRARY_PATH="${DESTDIR}/usr/lib:${DESTDIR}/lib" "${DESTDIR}/usr/sbin/grub-probe" --target="fs" "${DESTDIR}/usr" 2>/dev/null)"
    
    USR_PART_FS_LABEL="$(LD_LIBRARY_PATH="${DESTDIR}/usr/lib:${DESTDIR}/lib" "${DESTDIR}/usr/sbin/grub-probe" --target="fs_label" "${DESTDIR}/usr" 2>/dev/null)"
    
    USR_PART_HINTS_STRING="$(LD_LIBRARY_PATH="${DESTDIR}/usr/lib:${DESTDIR}/lib" "${DESTDIR}/usr/sbin/grub-probe" --target="hints_string" "${DESTDIR}/usr" 2>/dev/null)"
    
    ########
    
    if [[ "${GRUB_UEFI}" == "1" ]]; then
        UEFISYS_PART_FS_UUID="$(LD_LIBRARY_PATH="${DESTDIR}/usr/lib:${DESTDIR}/lib" "${DESTDIR}/usr/sbin/grub-probe" --target="fs_uuid" "${DESTDIR}/boot/efi" 2>/dev/null)"
        
        UEFISYS_PART_FS_LABEL="$(LD_LIBRARY_PATH="${DESTDIR}/usr/lib:${DESTDIR}/lib" "${DESTDIR}/usr/sbin/grub-probe" --target="fs_label" "${DESTDIR}/boot/efi" 2>/dev/null)"
        UEFISYS_PART_DRIVE="$(LD_LIBRARY_PATH="${DESTDIR}/usr/lib:${DESTDIR}/lib" "${DESTDIR}/usr/sbin/grub-probe" --target="drive" "${DESTDIR}/boot/efi" 2>/dev/null)"
        
        UEFISYS_PART_HINTS_STRING="$(LD_LIBRARY_PATH="${DESTDIR}/usr/lib:${DESTDIR}/lib" "${DESTDIR}/usr/sbin/grub-probe" --target="hints_string" "${DESTDIR}/boot/efi" 2>/dev/null)"
    fi
    
    ########
    
    ## udev 180 onwards
    if [[ "$(${_BLKID} -p -i  -o value -s PART_ENTRY_SCHEME ${ROOT_PART_DEVICE})" == 'gpt' ]]; then
        ROOT_PART_GPT_GUID="$(${_BLKID} -p -i -o value -s PART_ENTRY_UUID ${ROOT_PART_DEVICE})"
        ROOT_PART_GPT_LABEL="$(${_BLKID} -p -i -o value -s PART_ENTRY_NAME ${ROOT_PART_DEVICE})"
    fi
    
    ########
    
    if [[ "${ROOT_PART_FS_UUID}" == "${BOOT_PART_FS_UUID}" ]]; then
        subdir="/boot"
    else
        subdir=""
    fi
    
    ########
    
    ## Move old config file, if any
    mv "${DESTDIR}/${GRUB_PREFIX_DIR}/grub.cfg" "${DESTDIR}/${GRUB_PREFIX_DIR}/grub.cfg.bak" || true
    
    ## Ignore if the insmod entries are repeated - there are possibilities of having /boot in one disk and root-fs in altogether different disk
    ## with totally different configuration.
    
    cat << EOF > "${DESTDIR}/${GRUB_PREFIX_DIR}/grub.cfg"

if [ "\${grub_platform}" == "efi" ]; then
    set _UEFI_ARCH="\${grub_cpu}"
    
    if [ "\${grub_cpu}" == "x86_64" ]; then
        set _SPEC_UEFI_ARCH="x64"
    fi
    
    if [ "\${grub_cpu}" == "i386" ]; then
        set _SPEC_UEFI_ARCH="ia32"
    fi
fi

EOF
    
    cat << EOF >> "${DESTDIR}/${GRUB_PREFIX_DIR}/grub.cfg"

insmod part_gpt
insmod part_msdos

# Include fat fs module - required for uefi systems.
insmod fat

insmod ${BOOT_PART_FS}
insmod ${ROOT_PART_FS}
insmod ${USR_PART_FS}

insmod search_fs_file
insmod search_fs_uuid
insmod search_label

insmod linux
insmod chain

set pager="1"
# set debug="all"

set locale_dir="\${prefix}/locale"

EOF
    
    [[ "${USE_RAID}" == "1" ]] && echo "insmod raid" >> "${DESTDIR}/${GRUB_PREFIX_DIR}/grub.cfg"
    ! [[ "${RAID_ON_LVM}" == "" ]] && echo "insmod lvm" >> "${DESTDIR}/${GRUB_PREFIX_DIR}/grub.cfg"
    
    cat << EOF >> "${DESTDIR}/${GRUB_PREFIX_DIR}/grub.cfg"

if [ -e "\${prefix}/\${grub_cpu}-\${grub_platform}/all_video.mod" ]; then
    insmod all_video
else
    if [ "\${grub_platform}" == "efi" ]; then
        insmod efi_gop
        insmod efi_uga
    fi
    
    if [ "\${grub_platform}" == "pc" ]; then
        insmod vbe
        insmod vga
    fi
    
    insmod video_bochs
    insmod video_cirrus
fi

insmod font

search --fs-uuid --no-floppy --set=usr_part ${USR_PART_HINTS_STRING} ${USR_PART_FS_UUID}
search --fs-uuid --no-floppy --set=root_part ${ROOT_PART_HINTS_STRING} ${ROOT_PART_FS_UUID}

if [ -e "(\${usr_part})/share/grub/unicode.pf2" ]; then
    set _fontfile="(\${usr_part})/share/grub/unicode.pf2"
else
    if [ -e "(\${root_part})/usr/share/grub/unicode.pf2" ]; then
        set _fontfile="(\${root_part})/usr/share/grub/unicode.pf2"
    else
        if [ -e "\${prefix}/fonts/unicode.pf2" ]; then
            set _fontfile="\${prefix}/fonts/unicode.pf2"
        fi
    fi
fi

if loadfont "\${_fontfile}" ; then
    insmod gfxterm
    set gfxmode="auto"
    
    terminal_input console
    terminal_output gfxterm
fi

EOF
    
    echo "" >> "${DESTDIR}/${GRUB_PREFIX_DIR}/grub.cfg"
    sort "/tmp/.device-names" >> "${DESTDIR}/${GRUB_PREFIX_DIR}/grub.cfg"
    echo "" >> "${DESTDIR}/${GRUB_PREFIX_DIR}/grub.cfg"
    
    if [[ "${NAME_SCHEME_PARAMETER}" == "FSUUID" ]]; then
        GRUB_ROOT_DRIVE="search --fs-uuid --no-floppy --set=root ${BOOT_PART_HINTS_STRING} ${BOOT_PART_FS_UUID}"
        _rootpart="UUID=${ROOT_PART_FS_UUID}"
        
    elif [[ "${NAME_SCHEME_PARAMETER}" == "PARTUUID" ]]; then
        GRUB_ROOT_DRIVE="search --fs-uuid --no-floppy --set=root ${BOOT_PART_HINTS_STRING} ${BOOT_PART_FS_UUID}" # GRUB(2) does not yet support PARTUUID
        _rootpart="PARTUUID=${ROOT_PART_GPT_GUID}"
        
    elif [[ "${NAME_SCHEME_PARAMETER}" == "FSLABEL" ]]; then
        GRUB_ROOT_DRIVE="search --label --no-floppy --set=root ${BOOT_PART_HINTS_STRING} ${BOOT_PART_FS_LABEL}"
        _rootpart="LABEL=${ROOT_PART_FS_LABEL}"
        
    elif [[ "${NAME_SCHEME_PARAMETER}" == "PARTLABEL" ]]; then
        GRUB_ROOT_DRIVE="search --label --no-floppy --set=root ${BOOT_PART_HINTS_STRING} ${BOOT_PART_FS_LABEL}" # GRUB(2) does not yet support PARTLABEL
        _rootpart="PARTLABEL=${ROOT_PART_GPT_LABEL}"
        
    else
        GRUB_ROOT_DRIVE="set root="${BOOT_PART_DRIVE}""
        _rootpart="${ROOT_PART_DEVICE}"
        
    fi
    
    # fallback to device if no label or uuid can be detected, eg. luks device
    if [[ -z "${ROOT_PART_FS_UUID}" ]] && [[ -z "${ROOT_PART_FS_LABEL}" ]]; then
        _rootpart="${ROOT_PART_DEVICE}"
    fi
    
    LINUX_UNMOD_COMMAND="linux ${subdir}/${VMLINUZ} root=${_rootpart} ${ROOTFLAGS} rootfstype=${ROOTFS} ${RAIDARRAYS} ${CRYPTSETUP} ro"
    LINUX_MOD_COMMAND=$(echo "${LINUX_UNMOD_COMMAND}" | sed -e 's#   # #g' | sed -e 's#  # #g')
    
    ## create default kernel entry
    
    NUMBER="0"
    
    cat << EOF >> "${DESTDIR}/${GRUB_PREFIX_DIR}/grub.cfg"

# (${NUMBER}) Manjaro Linux
menuentry "Manjaro Linux" {
    set gfxpayload="keep"
    ${GRUB_ROOT_DRIVE}
    ${LINUX_MOD_COMMAND}
    initrd ${subdir}/${INITRAMFS}.img
}

EOF
    
    NUMBER=$((${NUMBER}+1))
    
    ## create kernel fallback entry
    cat << EOF >> "${DESTDIR}/${GRUB_PREFIX_DIR}/grub.cfg"

# (${NUMBER}) Manjaro Linux Fallback
menuentry "Manjaro Linux Fallback" {
    set gfxpayload="keep"
    ${GRUB_ROOT_DRIVE}
    ${LINUX_MOD_COMMAND}
    initrd ${subdir}/${INITRAMFS}-fallback.img
}

EOF
    
    NUMBER=$((${NUMBER}+1))
    
    cat << EOF >> "${DESTDIR}/${GRUB_PREFIX_DIR}/grub.cfg"

if [ "\${grub_platform}" == "efi" ]; then
    
    ## UEFI Shell 2.0
    ## Will work only in grub(2) uefi
    #menuentry "UEFI \${_UEFI_ARCH} Shell 2.0 - For Spec. Ver. >=2.3 systems" {
    #    search --fs-uuid --no-floppy --set=root ${UEFISYS_PART_HINTS_STRING} ${UEFISYS_PART_FS_UUID}
    #    chainloader /efi/tools/shell\${_SPEC_UEFI_ARCH}.efi
    #}
    
    ## UEFI Shell 1.0
    ## Will work only in grub(2) uefi
    #menuentry "UEFI \${_UEFI_ARCH} Shell 1.0 - For Spec. Ver. <2.3 systems" {
    #    search --fs-uuid --no-floppy --set=root ${UEFISYS_PART_HINTS_STRING} ${UEFISYS_PART_FS_UUID}
    #    chainloader /efi/tools/shell\${_SPEC_UEFI_ARCH}_old.efi
    #}
    
fi

EOF
    
    NUMBER=$((${NUMBER}+1))
    
    cat << EOF >> "${DESTDIR}/${GRUB_PREFIX_DIR}/grub.cfg"

if [ "\${grub_platform}" == "efi" ]; then
    
    ## Windows x86_64 UEFI
    ## Will work only in grub(2) uefi x86_64
    #menuentry \"Microsoft Windows x86_64 UEFI-GPT\" {
    #    insmod part_gpt
    #    insmod fat
    #    insmod search_fs_uuid
    #    insmod chain
    #    search --fs-uuid --no-floppy --set=root ${UEFISYS_PART_HINTS_STRING} ${UEFISYS_PART_FS_UUID}
    #    chainloader /efi/Microsoft/Boot/bootmgfw.efi
    #}
    
fi

EOF
    
    NUMBER=$((${NUMBER}+1))
    
    ## TODO: Detect actual Windows installation if any
    ## create example file for windows
    cat << EOF >> "${DESTDIR}/${GRUB_PREFIX_DIR}/grub.cfg"

if [ "\${grub_platform}" == "pc" ]; then
    
    ## Windows BIOS
    ## Will work only in grub(2) bios
    #menuentry \"Microsoft Windows 7 BIOS-MBR\" {
    #    insmod part_msdos
    #    insmod ntfs
    #    insmod search_fs_uuid
    #    insmod ntldr
    #    search --fs-uuid --no-floppy --set=root 69B235F6749E84CE
    #    ntldr /bootmgr
    #}
    
fi

EOF
    
    ## copy unicode.pf2 font file
    cp -f "${DESTDIR}/usr/share/grub/unicode.pf2" "${DESTDIR}/${GRUB_PREFIX_DIR}/fonts/unicode.pf2"
    
    ## Edit grub.cfg config file
    DIALOG --msgbox "You must now review the grub(2) configuration file.\n\nYou will now be put into the editor. After you save your changes, exit the editor." 0 0
    geteditor || return 1
    "${EDITOR}" "${DESTDIR}/${GRUB_PREFIX_DIR}/grub.cfg"
    
    unset BOOT_PART_FS_UUID
    unset BOOT_PART_FS
    unset BOOT_PART_FS_LABEL
    unset BOOT_PART_DRIVE
    
    unset ROOT_PART_FS_UUID
    unset ROOT_PART_FS
    unset ROOT_PART_FS_LABEL
    unset ROOT_PART_DEVICE
    
    unset GRUB_ROOT_DRIVE
    unset LINUX_UNMOD_COMMAND
    unset LINUX_MOD_COMMAND
    
}

dogrub_bios() {
    
    dogrub_common_before
    
    # try to auto-configure GRUB(2)...
    if [[ "${PART_ROOT}" != "" ]]; then
        check_bootpart
        
        # check if raid, raid partition, dmraid or device devicemapper is used
        if [[ "$(echo ${bootdev} | grep /dev/md)" ]] || [[ "$(echo ${bootdev} | grep /dev/mapper)" ]]; then
            # boot from lvm, raid, partitioned raid and dmraid devices is supported
            FAIL_COMPLEX="0"
            
            if [[ "$(cryptsetup status ${bootdev})" ]]; then
                # encryption devices are not supported
                FAIL_COMPLEX="1"
            fi
        fi
        
        if [[ "${FAIL_COMPLEX}" == "0" ]]; then
            grubdev=$(basename ${bootdev})
            complexuuid=$(getfsuuid ${bootdev})
            # check if mapper is used
            if  [[ "$(echo ${bootdev} | grep /dev/mapper)" ]]; then
                RAID_ON_LVM="0"
                
                #check if mapper contains a md device!
                for devpath in $(pvs -o pv_name --noheading); do
                    if [[ "$(echo ${devpath} | grep -v /dev/md*p | grep /dev/md)" ]]; then
                        detectedvolumegroup="$(echo $(pvs -o vg_name --noheading ${devpath}))"
                        
                        if [[ "$(echo /dev/mapper/${detectedvolumegroup}-* | grep ${bootdev})" ]]; then
                            # change bootdev to md device!
                            bootdev=$(pvs -o pv_name --noheading ${devpath})
                            RAID_ON_LVM="1"
                            break
                        fi
                    fi
                done
            fi
            
            #check if raid is used
            USE_RAID=""
            if [[ "$(echo ${bootdev} | grep /dev/md)" ]]; then
                USE_RAID="1"
            fi
        else
            # use normal device
            grubdev=$(mapdev ${bootdev})
        fi
    fi
    
    
    # A switch is needed if complex ${bootdev} is used!
    # - LVM and RAID ${bootdev} needs the MBR of a device and cannot be used itself as ${bootdev}
    if [[ "${FAIL_COMPLEX}" == "0" ]]; then
        DEVS="$(findbootloaderdisks _)"
        
        if [[ "${DEVS}" == "" ]]; then
            DIALOG --msgbox "No hard drives were found" 0 0
            return 1
        fi
        
        DIALOG --menu "Select the boot device where the GRUB(2) bootloader will be installed." 14 55 7 ${DEVS} 2>${ANSWER} || return 1
        bootdev=$(cat ${ANSWER})
    else
        DEVS="$(findbootloaderdisks _)"
        
        ## grub-bios install to partition is not supported
        # DEVS="${DEVS} $(findbootloaderpartitions _)"
        
        if [[ "${DEVS}" == "" ]]; then
            DIALOG --msgbox "No hard drives were found" 0 0
            return 1
        fi
        
        DIALOG --menu "Select the boot device where the GRUB(2) bootloader will be installed (usually the MBR  and not a partition)." 14 55 7 ${DEVS} 2>${ANSWER} || return 1
        bootdev=$(cat ${ANSWER})
    fi
    
    if [[ "$(${_BLKID} -p -i -o value -s PTTYPE ${bootdev})" == "gpt" ]]; then
        CHECK_BIOS_BOOT_GRUB="1"
        CHECK_UEFISYS_PART=""
        RUN_CGDISK=""
        DISC="${bootdev}"
        check_gpt
    else
        if [[ "${FAIL_COMPLEX}" == "0" ]]; then
            DIALOG --defaultno --yesno "Warning:\nSetup detected no GUID (gpt) partition table.\n\nGrub(2) has only space for approx. 30k core.img file. Depending on your setup, it might not fit into this gap and fail.\n\nDo you really want to install grub(2) to a msdos partition table?" 0 0 || return 1
        fi
    fi
    
    if [[ "${FAIL_COMPLEX}" == "1" ]]; then
        DIALOG --msgbox "Error:\nGrub(2) cannot boot from ${bootdev}, which contains /boot!\n\nPossible error sources:\n- encrypted devices are not supported" 0 0
        return 1
    fi
    
    DIALOG --infobox "Installing the GRUB(2) BIOS bootloader..." 0 0
    # freeze and unfreeze xfs filesystems to enable grub(2) installation on xfs filesystems
    freeze_xfs
    chroot_mount
    
    chroot "${DESTDIR}" "/usr/sbin/grub-install" \
        --directory="/usr/lib/grub/i386-pc" \
        --target="i386-pc" \
        --boot-directory="/boot" \
        --recheck \
        --debug \
        "${bootdev}" &>"/tmp/grub_bios_install.log"
    
    chroot_umount
    
    mkdir -p "${DESTDIR}/boot/grub/locale"
    cp -f "${DESTDIR}/usr/share/locale/en@quot/LC_MESSAGES/grub.mo" "${DESTDIR}/boot/grub/locale/en.mo"
     
    if [[ -e "${DESTDIR}/boot/grub/i386-pc/core.img" ]]; then
        DIALOG --msgbox "GRUB(2) BIOS has been successfully installed." 0 0
        
        GRUB_PREFIX_DIR="/boot/grub/"
        GRUB_BIOS="1"
        #dogrub_config
        dogrub_mkconfig
        GRUB_BIOS=""
    else
        DIALOG --msgbox "Error installing GRUB(2) BIOS.\nCheck /tmp/grub_bios_install.log for more info.\n\nYou probably need to install it manually by chrooting into ${DESTDIR}.\nDon't forget to bind /dev and /proc into ${DESTDIR} before chrooting." 0 0
        return 1
    fi
    
}

dogrub_uefi_common() {
    
    dogrub_common_before
    
    chroot_mount
    
    chroot "${DESTDIR}" "/usr/sbin/grub-install" \
        --directory="/usr/lib/grub/${_UEFI_ARCH}-efi" \
        --target="${_UEFI_ARCH}-efi" \
        --efi-directory="/boot/efi" \
        --bootloader-id="manjaro_grub" \
        --boot-directory="/boot" \
        --recheck \
        --debug &>"/tmp/grub_uefi_${_UEFI_ARCH}_install.log"
    
    chroot_umount
    
    mkdir -p "${DESTDIR}/boot/grub/locale"
    cp -f "${DESTDIR}/usr/share/locale/en@quot/LC_MESSAGES/grub.mo" "${DESTDIR}/boot/grub/locale/en.mo"
    
    BOOT_PART_FS_UUID="$(LD_LIBRARY_PATH="${DESTDIR}/usr/lib:${DESTDIR}/lib" "${DESTDIR}/usr/sbin/grub-probe" --target="fs_uuid" "${DESTDIR}/boot" 2>/dev/null)"
    BOOT_PART_FS="$(LD_LIBRARY_PATH="${DESTDIR}/usr/lib:${DESTDIR}/lib" "${DESTDIR}/usr/sbin/grub-probe" --target="fs" "${DESTDIR}/boot" 2>/dev/null)"
    
    BOOT_PART_HINTS_STRING="$(LD_LIBRARY_PATH="${DESTDIR}/usr/lib:${DESTDIR}/lib" "${DESTDIR}/usr/sbin/grub-probe" --target="hints_string" "${DESTDIR}/boot" 2>/dev/null)"
    
    [[ -e "${DESTDIR}/boot/grub/grub.cfg" ]] && mv "${DESTDIR}/boot/grub/grub.cfg" "${DESTDIR}/boot/grub/grub.cfg.save"
    
    cat << EOF > "${DESTDIR}/boot/grub/grub.cfg"

insmod usbms
insmod usb_keyboard

insmod part_gpt
insmod part_msdos

insmod fat
insmod iso9660
insmod udf
insmod ${BOOT_PART_FS}

insmod ext2
insmod reiserfs
insmod ntfs
insmod hfsplus

insmod linux
insmod chain

search --fs-uuid --no-floppy --set=root ${BOOT_PART_HINTS_STRING} ${BOOT_PART_FS_UUID}

if [ -f "(\${root})/grub/grub.cfg" ]; then
    set prefix="(\${root})/grub"
    source "(\${root})/grub/grub.cfg"
else
    if [ -f "(\${root})/boot/grub/grub.cfg" ]; then
        set prefix="(\${root})/boot/grub"
        source "(\${root})/boot/grub/grub.cfg"
    fi
fi

EOF
    
    cp -f "${DESTDIR}/boot/grub/grub.cfg" "${DESTDIR}/boot/efi/EFI/manjaro_grub/grub${_SPEC_UEFI_ARCH}_standalone.cfg"
    
    __WD="${PWD}/"
    
    cd "${DESTDIR}/"
    
    chroot_mount
    
    chroot "${DESTDIR}" "/usr/bin/grub-mkstandalone" \
        --directory="/usr/lib/grub/${_UEFI_ARCH}-efi" \
        --format="${_UEFI_ARCH}-efi" \
        --compression="xz" \
        --output="/boot/efi/EFI/manjaro_grub/grub${_SPEC_UEFI_ARCH}_standalone.efi" \
        "boot/grub/grub.cfg" &>"/tmp/grub_${_UEFI_ARCH}_uefi_mkstandalone.log"
    
    chroot_umount
    
    cd "${__WD}/"
    
    [[ -e "${DESTDIR}/boot/grub/grub.cfg.save" ]] && mv "${DESTDIR}/boot/grub/grub.cfg.save" "${DESTDIR}/boot/grub/grub.cfg"
    
    cat "/tmp/grub_uefi_${_UEFI_ARCH}_install.log" >> "${LOG}"
    
    if [[ -e "${DESTDIR}/boot/efi/EFI/manjaro_grub/grub${_SPEC_UEFI_ARCH}.efi" ]] && [[ -e "${DESTDIR}/boot/grub/${_UEFI_ARCH}-efi/core.efi" ]]; then
        _BOOTMGR_LABEL="Manjaro Linux (GRUB)"
        _BOOTMGR_LOADER_DIR="manjaro_grub"
        _BOOTMGR_LOADER_FILE="grub${_SPEC_UEFI_ARCH}.efi"
        do_uefi_bootmgr_setup
        
        DIALOG --msgbox "GRUB(2) UEFI ${_UEFI_ARCH} has been successfully installed." 0 0
        
        GRUB_PREFIX_DIR="/boot/grub/"
        GRUB_UEFI="1"
        #dogrub_config
        dogrub_mkconfig
        GRUB_UEFI=""
        
        DIALOG --defaultno --yesno "Do you want to copy /boot/efi/EFI/manjaro_grub/grub${_SPEC_UEFI_ARCH}.efi to /boot/efi/EFI/boot/boot${_SPEC_UEFI_ARCH}.efi ?\n\nThis might be needed in some systems where efibootmgr may not work due to firmware issues." 0 0 && _UEFISYS_EFI_BOOT_DIR="1"
        
        if [[ "${_UEFISYS_EFI_BOOT_DIR}" == "1" ]]; then
            mkdir -p "${DESTDIR}/boot/efi/EFI/boot"
            
            rm -f "${DESTDIR}/boot/efi/EFI/boot/boot${_SPEC_UEFI_ARCH}.efi"
            
            cp -f "${DESTDIR}/boot/efi/EFI/manjaro_grub/grub${_SPEC_UEFI_ARCH}.efi" "${DESTDIR}/boot/efi/EFI/boot/boot${_SPEC_UEFI_ARCH}.efi"
        fi
    else
        DIALOG --msgbox "Error installing GRUB UEFI ${_UEFI_ARCH}.\nCheck /tmp/grub_uefi_${_UEFI_ARCH}_install.log for more info.\n\nYou probably need to install it manually by chrooting into ${DESTDIR}.\nDon't forget to bind /dev, /sys and /proc into ${DESTDIR} before chrooting." 0 0
        return 1
    fi
    
}

dogrub_uefi_x86_64() {
    
    do_uefi_x86_64
    
    dogrub_uefi_common
    
}

dogrub_uefi_i386() {
    
    do_uefi_i386
    
    dogrub_uefi_common
    
}

# menu for raid, lvm and encrypt
create_special() {
    NEXTITEM=""
    SPECIALDONE=0
    while [[ "${SPECIALDONE}" = "0" ]]; do
        if [[ -n "${NEXTITEM}" ]]; then
            DEFAULT="--default-item ${NEXTITEM}"
        else
            DEFAULT=""
        fi
        CANCEL=""
        dialog ${DEFAULT} --backtitle "${TITLE}" --menu "Create Software Raid, LVM2 and Luks encryption" 14 60 5 \
            "1" "Create Software Raid" \
            "2" "Create LVM2" \
            "3" "Create Luks encryption" \
            "4" "Return to Previous Menu" 2>${ANSWER} || CANCEL="1"
        NEXTITEM="$(cat ${ANSWER})"
        case $(cat ${ANSWER}) in
            "1")
                _createmd ;;
            "2")
                _createlvm ;;
            "3")
                _createluks ;;
            *)
                SPECIALDONE=1 ;;
        esac
    done
    if [[ "${CANCEL}" = "1" ]]; then
        NEXTITEM="3"
    else
        NEXTITEM="4"
    fi
}

# menu for md creation
_createmd() {
    NEXTITEM=""
    MDDONE=0
    while [[ "${MDDONE}" = "0" ]]; do
        if [[ -n "${NEXTITEM}" ]]; then
            DEFAULT="--default-item ${NEXTITEM}"
        else
            DEFAULT=""
        fi
        CANCEL=""
        dialog ${DEFAULT} --backtitle "${TITLE}" --menu "Create Software Raid" 12 60 5 \
            "1" "Raid Help" \
            "2" "Reset Software Raid completely" \
            "3" "Create Software Raid" \
            "4" "Create Partitionable Software Raid" \
            "5" "Return to Previous Menu" 2>${ANSWER} || CANCEL="1"
        NEXTITEM="$(cat ${ANSWER})"
        case $(cat ${ANSWER}) in
            "1")
                _helpraid ;;
            "2")
                _stopmd ;;
            "3")
                RAID_PARTITION=""
                _raid ;;
            "4")
                RAID_PARTITION="1"
                _raid ;;
              *)
                MDDONE=1 ;;
        esac
    done
    if [[ "${CANCEL}" = "1" ]]; then
        NEXTITEM="1"
    else
        NEXTITEM="4"
    fi
}

# menu for lvm creation
_createlvm() {
    NEXTITEM=""
    LVMDONE=0
    while [[ "${LVMDONE}" = "0" ]]; do
        if [[ -n "${NEXTITEM}" ]]; then
            DEFAULT="--default-item ${NEXTITEM}"
        else
            DEFAULT=""
        fi
        CANCEL=""
        dialog ${DEFAULT} --backtitle "${TITLE}" --menu "Create physical volume, volume group or logical volume" 13 60 7 \
            "1" "LVM Help" \
            "2" "Reset Logical Volume completely" \
            "3" "Create Physical Volume" \
            "4" "Create Volume Group" \
            "5" "Create Logical Volume" \
            "6" "Return to Previous Menu" 2>${ANSWER} || CANCEL="1"
        NEXTITEM="$(cat ${ANSWER})"
        case $(cat ${ANSWER}) in
            "1")
                _helplvm ;;
            "2")
                _stoplvm ;;
            "3")
                _createpv ;;
            "4")
                _createvg ;;
            "5")
                _createlv ;;
              *)
                LVMDONE=1 ;;
        esac
    done
    if [[ "${CANCEL}" = "1" ]]; then
        NEXTITEM="2"
    else
        NEXTITEM="4"
    fi
}

# menu for luks creation
_createluks() {
    NEXTITEM=""
    LUKSDONE=0
    while [[ "${LUKSDONE}" = "0" ]]; do
        if [[ -n "${NEXTITEM}" ]]; then
            DEFAULT="--default-item ${NEXTITEM}"
        else
            DEFAULT=""
        fi
        CANCEL=""
        dialog ${DEFAULT} --backtitle "${TITLE}" --menu "Create Luks Encryption" 12 60 5 \
            "1" "Luks Help" \
            "2" "Reset Luks Encryption completely" \
            "3" "Create Luks" \
            "4" "Return to Previous Menu" 2>${ANSWER} || CANCEL="1"
        NEXTITEM="$(cat ${ANSWER})"
        case $(cat ${ANSWER}) in
            "1")
                _helpluks ;;
            "2")
                _stopluks ;;
            "3")
                _luks ;;
              *)
                LUKSDONE=1 ;;
        esac
    done
    if [[ "${CANCEL}" = "1" ]]; then
        NEXTITEM="3"
    else
        NEXTITEM="4"
    fi
}

# installsystem()
# installs to the target folder
installsystem() {
    DIALOG --msgbox "${_installationwillstart}" 0 0
    clear
    mkdir -p ${DESTDIR}
    #unsquashfs -f -d ${DESTDIR} /bootmnt/manjaro/${arch}/root-image.sqfs
    UNSQUASH_TARGET=${DESTDIR}
    SQF_FILE=root-image.sqfs
    run_unsquashfs
    echo $? > /tmp/.install-retcode
    if [ $(cat /tmp/.install-retcode) -ne 0 ]; then echo -e "\n${_installationfail}" >>/tmp/unsquasherror.log
    else echo -e "\n => Root-Image: ${_installationsuccess}" >>/tmp/unsquasherror.log
    fi
    sed -i '/dir_scan: failed to open directory [^ ]*, because File exists/d' /tmp/unsquasherror.log

    if [ -e "/bootmnt/manjaro/${arch}/xfce-image.sqfs" ] ; then
       #unsquashfs -f -d ${DESTDIR} /bootmnt/manjaro/${arch}/xfce-image.sqfs
       UNSQUASH_TARGET=${DESTDIR}
       SQF_FILE=xfce-image.sqfs
       run_unsquashfs
       echo $? > /tmp/.install-retcode
       if [ $(cat /tmp/.install-retcode) -ne 0 ]; then echo -e "\n${_installationfail}" >>/tmp/unsquasherror.log
       else echo -e "\n => XFCE-Image: ${_installationsuccess}" >>/tmp/unsquasherror.log
       fi
       sed -i '/dir_scan: failed to open directory [^ ]*, because File exists/d' /tmp/unsquasherror.log
    fi

    if [ -e "/bootmnt/manjaro/${arch}/kde-image.sqfs" ] ; then
       #unsquashfs -f -d ${DESTDIR} /bootmnt/manjaro/${arch}/kde-image.sqfs
       UNSQUASH_TARGET=${DESTDIR}
       SQF_FILE=kde-image.sqfs
       run_unsquashfs
       echo $? > /tmp/.install-retcode
       if [ $(cat /tmp/.install-retcode) -ne 0 ]; then echo -e "\n${_installationfail}" >>/tmp/unsquasherror.log
       else echo -e "\n => KDE-Image: ${_installationsuccess}" >>/tmp/unsquasherror.log
       fi
       sed -i '/dir_scan: failed to open directory [^ ]*, because File exists/d' /tmp/unsquasherror.log
    fi

    if [ -e "/bootmnt/manjaro/${arch}/gnome-image.sqfs" ] ; then
       #unsquashfs -f -d ${DESTDIR} /bootmnt/manjaro/${arch}/gnome-image.sqfs
       UNSQUASH_TARGET=${DESTDIR}
       SQF_FILE=gnome-image.sqfs
       run_unsquashfs
       echo $? > /tmp/.install-retcode
       if [ $(cat /tmp/.install-retcode) -ne 0 ]; then echo -e "\n${_installationfail}" >>/tmp/unsquasherror.log
       else echo -e "\n => Gnome-Image: ${_installationsuccess}" >>/tmp/unsquasherror.log
       fi
       sed -i '/dir_scan: failed to open directory [^ ]*, because File exists/d' /tmp/unsquasherror.log
    fi

    if [ -e "/bootmnt/manjaro/${arch}/openbox-image.sqfs" ] ; then
       #unsquashfs -f -d ${DESTDIR} /bootmnt/manjaro/${arch}/openbox-image.sqfs
       UNSQUASH_TARGET=${DESTDIR}
       SQF_FILE=openbox-image.sqfs
       run_unsquashfs
       echo $? > /tmp/.install-retcode
       if [ $(cat /tmp/.install-retcode) -ne 0 ]; then echo -e "\n${_installationfail}" >>/tmp/unsquasherror.log
       else echo -e "\n => Openbox-Image: ${_installationsuccess}" >>/tmp/unsquasherror.log
       fi
       sed -i '/dir_scan: failed to open directory [^ ]*, because File exists/d' /tmp/unsquasherror.log
    fi

    # finished, display scrollable output
    local _result=''
    if [ $(cat /tmp/.install-retcode) -ne 0 ]; then
      _result="${_installationfail}"
    else
      _result="${_installationsuccess}"
    fi
    rm /tmp/.install-retcode

    DIALOG --title "$_result" --exit-label "${_continue_label}" \
        --textbox "/tmp/unsquasherror.log" 18 60 || return 1

    # ensure the disk is synced
    sync

    S_INSTALL=1
    NEXTITEM=4

    # automagic time!
    # any automatic configuration should go here
    DIALOG --infobox "${_configuringsystem}" 6 40
    sleep 3

    hd_config
    auto_fstab
    _system_is_installed=1
}

install_bootloader_uefi_x86_64() {
    
    DIALOG --menu "Which x86_64 UEFI bootloader would you like to use?" 13 55 2 \
        "EFISTUB_x86_64" "Only x86_64 Kernels" \
        "GRUB_UEFI_x86_64" "GRUB(2) x86_64 UEFI" 2>${ANSWER} || CANCEL=1
    case $(cat ${ANSWER}) in
        "EFISTUB_x86_64") do_efistub_uefi_x86_64 ;;
        "GRUB_UEFI_x86_64") dogrub_uefi_x86_64 ;;
    esac
    
}

install_bootloader_uefi_i386() {
    
    DIALOG --menu "Which i386 UEFI bootloader would you like to use?" 13 55 2 \
        "EFISTUB_i686" "Only i686 Kernels" \
        "GRUB_UEFI_i386" "GRUB(2) i386 UEFI" 2>${ANSWER} || CANCEL=1
    case $(cat ${ANSWER}) in
        "EFISTUB_i686") do_efistub_uefi_i686 ;;
        "GRUB_UEFI_i386") dogrub_uefi_i386 ;;
    esac
    
}

install_bootloader_bios() {
    
    DIALOG --menu "Which BIOS bootloader would you like to use?" 11 50 4 \
        "SYSLINUX_BIOS" "SYSLINUX/EXTLINUX" \
        "GRUB_BIOS" "GRUB(2) BIOS" 2>${ANSWER} || CANCEL=1
    case $(cat ${ANSWER}) in
        "SYSLINUX_BIOS") dosyslinux_bios ;;
        "GRUB_BIOS") dogrub_bios ;;
    esac
    
}

install_bootloader() {
    
    destdir_mounts || return 1
    if [[ "${NAME_SCHEME_PARAMETER_RUN}" == "" ]]; then
        set_device_name_scheme || return 1
    fi
    CANCEL=""
    
    _DIRECT="0"
    
    [[ "$(grep UEFI_ARCH_x86_64 /proc/cmdline)" ]] && _UEFI_x86_64="1"
    
    [[ "${_UEFI_x86_64}" == "1" ]] && DIALOG --yesno "Setup has detected that you are using x86_64 (64-bit) UEFI ...\nDo you like to install a x86_64 UEFI bootloader?" 0 0 && install_bootloader_uefi_x86_64 && _DIRECT="1"
    
    if [[ "${_DIRECT}" == "1" ]]; then
        DIALOG --yesno "Do you want to install another bootloader?" 0 0 && install_bootloader_menu && _DIRECT="0"
    else
        install_bootloader_menu
    fi
}

install_bootloader_menu() {
    
    DIALOG --menu "What is your boot system type?" 10 40 3 \
        "BIOS" "BIOS" \
        "UEFI_x86_64" "x86_64 UEFI" \
        "UEFI_i386" "i386 UEFI" 2>${ANSWER} || CANCEL=1
    case $(cat ${ANSWER}) in
        "BIOS") install_bootloader_bios ;;
        "UEFI_x86_64") install_bootloader_uefi_x86_64 ;;
        "UEFI_i386") install_bootloader_uefi_i386 ;;
    esac
    
    if [[ "${CANCEL}" = "1" ]]; then
        NEXTITEM="5"
    else
        NEXTITEM="6"
    fi
}

hd_config()
{
    # initialize special directories
    rm -v -rf ${DESTDIR}/sys ${DESTDIR}/proc ${DESTDIR}/dev &>/dev/null
    mkdir -p -v -m 1777 ${DESTDIR}/tmp &>/dev/null
    mkdir -p -v -m 1777 ${DESTDIR}/var/tmp &>/dev/null
    mkdir -p -v ${DESTDIR}/var/log/old &>/dev/null
    mkdir -p -v ${DESTDIR}/var/lock/sane &>/dev/null
    mkdir -p -v ${DESTDIR}/var/cache/pacman/pkg &>/dev/null
    mkdir -p -v ${DESTDIR}/boot/grub &>/dev/null
    mkdir -p -v ${DESTDIR}/usr/lib/locale &>/dev/null
    mkdir -p -v ${DESTDIR}/usr/share/icons/default &>/dev/null
    mkdir -p -v ${DESTDIR}/media &>/dev/null
    mkdir -p -v ${DESTDIR}/mnt &>/dev/null
    mkdir -p -v ${DESTDIR}/sys &>/dev/null
    mkdir -p -v ${DESTDIR}/proc &>/dev/null

    # create the basic devices (/dev/{console,null,zero}) on the target
    mkdir -p -v ${DESTDIR}/dev &>/dev/null &>/dev/null
    mknod ${DESTDIR}/dev/console c 5 1 &>/dev/null
    mknod ${DESTDIR}/dev/null c 1 3 &>/dev/null
    mknod ${DESTDIR}/dev/zero c 1 5 &>/dev/null

    # adjust permissions on /tmp and /var/tmp
    chmod -v 777 ${DESTDIR}/var/tmp &>/dev/null
    chmod -v o+t ${DESTDIR}/var/tmp &>/dev/null
    chmod -v 777 ${DESTDIR}/tmp &>/dev/null
    chmod -v o+t ${DESTDIR}/tmp &>/dev/null

    # install /etc/resolv.conf
    cp -vf /etc/resolv.conf ${DESTDIR}/etc/resolv.conf &>/dev/null

    echo "install configs for root" &>/dev/null
    cp -a ${DESTDIR}/etc/skel/. ${DESTDIR}/root/ &>/dev/null

    sed -i 's/^#\(en_US.*\)/\1/' ${DESTDIR}/etc/locale.gen &>/dev/null
    
    chroot_mount

    # copy generated xorg.xonf to target
    if [ -e "/etc/X11/xorg.conf" ] ; then
        echo "copying generated xorg.conf to target"
        cp /etc/X11/xorg.conf ${DESTDIR}/etc/X11/xorg.conf &>/dev/null
    fi

    #set_alsa

    DIALOG --infobox "${_setupalsa}"  6 40
    sleep 3
    # amixer binary
    local alsa_amixer=`chroot ${DESTDIR} /usr/bin/amixer`

    # enable all known (tm) outputs
    $alsa_amixer -c 0 sset "Master" 70% unmute &>/dev/null
    $alsa_amixer -c 0 sset "Front" 70% unmute &>/dev/null
    $alsa_amixer -c 0 sset "Side" 70% unmute &>/dev/null
    $alsa_amixer -c 0 sset "Surround" 70% unmute &>/dev/null
    $alsa_amixer -c 0 sset "Center" 70% unmute &>/dev/null
    $alsa_amixer -c 0 sset "LFE" 70% unmute &> /dev/null
    $alsa_amixer -c 0 sset "Headphone" 70% unmute &>/dev/null
    $alsa_amixer -c 0 sset "Speaker" 70% unmute &>/dev/null
    $alsa_amixer -c 0 sset "PCM" 70% unmute &>/dev/null
    $alsa_amixer -c 0 sset "Line" 70% unmute &>/dev/null
    $alsa_amixer -c 0 sset "External" 70% unmute &>/dev/null
    $alsa_amixer -c 0 sset "FM" 50% unmute &> /dev/null
    $alsa_amixer -c 0 sset "Master Mono" 70% unmute &>/dev/null
    $alsa_amixer -c 0 sset "Master Digital" 70% unmute &>/dev/null
    $alsa_amixer -c 0 sset "Analog Mix" 70% unmute &> /dev/null
    $alsa_amixer -c 0 sset "Aux" 70% unmute &> /dev/null
    $alsa_amixer -c 0 sset "Aux2" 70% unmute &> /dev/null
    $alsa_amixer -c 0 sset "PCM Center" 70% unmute &> /dev/null
    $alsa_amixer -c 0 sset "PCM Front" 70% unmute &> /dev/null
    $alsa_amixer -c 0 sset "PCM LFE" 70% unmute &> /dev/null
    $alsa_amixer -c 0 sset "PCM Side" 70% unmute &> /dev/null
    $alsa_amixer -c 0 sset "PCM Surround" 70% unmute &> /dev/null
    $alsa_amixer -c 0 sset "Playback" 70% unmute &> /dev/null
    $alsa_amixer -c 0 sset "PCM,1" 70% unmute &> /dev/null
    $alsa_amixer -c 0 sset "DAC" 70% unmute &> /dev/null
    $alsa_amixer -c 0 sset "DAC,0" 70% unmute &> /dev/null
    $alsa_amixer -c 0 sset "DAC,0" -12dB &> /dev/null
    $alsa_amixer -c 0 sset "DAC,1" 70% unmute &> /dev/null
    $alsa_amixer -c 0 sset "DAC,1" -12dB &> /dev/null
    $alsa_amixer -c 0 sset "Synth" 70% unmute &> /dev/null
    $alsa_amixer -c 0 sset "CD" 70% unmute &> /dev/null
    $alsa_amixer -c 0 sset "Wave" 70% unmute &> /dev/null
    $alsa_amixer -c 0 sset "Music" 70% unmute &> /dev/null
    $alsa_amixer -c 0 sset "AC97" 70% unmute &> /dev/null
    $alsa_amixer -c 0 sset "Analog Front" 70% unmute &> /dev/null
    $alsa_amixer -c 0 sset "VIA DXS,0" 70% unmute &> /dev/null
    $alsa_amixer -c 0 sset "VIA DXS,1" 70% unmute &> /dev/null
    $alsa_amixer -c 0 sset "VIA DXS,2" 70% unmute &> /dev/null
    $alsa_amixer -c 0 sset "VIA DXS,3" 70% unmute &> /dev/null

    # set input levels
    $alsa_amixer -c 0 sset "Mic" 70% mute &>/dev/null
    $alsa_amixer -c 0 sset "IEC958" 70% mute &>/dev/null

    # special stuff
    $alsa_amixer -c 0 sset "Master Playback Switch" on &>/dev/null
    $alsa_amixer -c 0 sset "Master Surround" on &>/dev/null
    $alsa_amixer -c 0 sset "SB Live Analog/Digital Output Jack" off &>/dev/null
    $alsa_amixer -c 0 sset "Audigy Analog/Digital Output Jack" off &>/dev/null

    # save settings
    chroot ${DESTDIR} alsactl -f /etc/asound.state store &>/dev/null

    # enable default mirror
    cp ${DESTDIR}/etc/pacman.d/mirrorlist ${DESTDIR}/etc/pacman.d/mirrorlist.backup
    sed -i -e 's~^.*repo.manjaro.org.uk.*~Server = http://repo.manjaro.org.uk/$repo/$arch~' ${DESTDIR}/etc/pacman.d/mirrorlist

    chroot ${DESTDIR} pacman -Syy &> /dev/null

    # Install xf86-video driver

    # TODO: fix in mhwd
    mkdir -p ${DESTDIR}/var/lib/mhwd/local/{pci,usb}

    if [ -e "/opt/manjaro/pacman-gfx.conf" ] ; then
       DIALOG --infobox "${_installvideodriver}"  6 40
    
       mkdir -p ${DESTDIR}/opt/manjaro
       mount -o bind /opt/manjaro ${DESTDIR}/opt/manjaro > /tmp/mount.pkgs.log
       ls ${DESTDIR}/opt/manjaro >> /tmp/mount.pkgs.log

       if  [ "${USENONFREE}" == "yes" ] || [ "${USENONFREE}" == "true" ]; then
	   if  [ "${VIDEO}" == "vesa" ]; then
           	chroot ${DESTDIR} /usr/bin/mhwd --install pci video-vesa --pmconfig "/opt/manjaro/pacman-gfx.conf" &>/dev/null
	   else
           	chroot ${DESTDIR} /usr/bin/mhwd --auto pci nonfree 0300 --pmconfig "/opt/manjaro/pacman-gfx.conf" &>/dev/null
	   fi
       else
	   if  [ "${VIDEO}" == "vesa" ]; then
           	chroot ${DESTDIR} /usr/bin/mhwd --install pci video-vesa --pmconfig "/opt/manjaro/pacman-gfx.conf" &>/dev/null
	   else
           	chroot ${DESTDIR} /usr/bin/mhwd --auto pci free 0300 --pmconfig "/opt/manjaro/pacman-gfx.conf" &>/dev/null
	   fi
       fi

       umount ${DESTDIR}/opt/manjaro
       rmdir ${DESTDIR}/opt/manjaro
    fi

    # setup systemd

    DIALOG --infobox "${_setupsystemd}" 6 40
    sleep 3

    chroot ${DESTDIR} systemctl enable cups.service &>/dev/null
    chroot ${DESTDIR} systemctl enable dcron.service &>/dev/null
    chroot ${DESTDIR} systemctl enable NetworkManager.service &>/dev/null
    chroot ${DESTDIR} systemctl enable remote-fs.target &>/dev/null

    DIALOG --infobox "${_setupdisplaymanager}" 6 40
    sleep 3

    # setup lightdm
    if [ -e "/usr/sbin/lightdm" ] ; then
       mkdir -p ${DESTDIR}/run/lightdm  &>/dev/null
       chroot ${DESTDIR} getent group lightdm > /dev/null 2>&1 || groupadd -g 620 lightdm
       chroot ${DESTDIR} getent passwd lightdm > /dev/null 2>&1 || useradd -c 'LightDM Display Manager' -u 620 -g lightdm -d /var/run/lightdm -s /sbin/nologin lightdm
       chroot ${DESTDIR} passwd -l lightdm > /dev/null
       chown -R lightdm:lightdm ${DESTDIR}/run/lightdm  &>/dev/null
       sed -i -e 's/^.*user-session=.*/user-session=xfce/' ${DESTDIR}/etc/lightdm/lightdm.conf
       chmod +r ${DESTDIR}/etc/lightdm/lightdm.conf &>/dev/null
    fi

    # setup gdm
    if [ -e "/usr/sbin/gdm" ] ; then
       chroot ${DESTDIR} getent group gdm >/dev/null 2>&1 || groupadd -g 120 gdm
       chroot ${DESTDIR} getent passwd gdm > /dev/null 2>&1 || usr/sbin/useradd -c 'Gnome Display Manager' -u 120 -g gdm -d /var/lib/gdm -s /sbin/nologin gdm
       chroot ${DESTDIR} passwd -l gdm > /dev/null
       chroot ${DESTDIR} chown -R gdm:gdm /var/lib/gdm  &>/dev/null
       sed -i '/AutomaticLoginEnable=true/ d' ${DESTDIR}/etc/gdm/custom.conf
       sed -i '/AutomaticLogin=manjaro/ d' ${DESTDIR}/etc/gdm/custom.conf
    fi

    # setup lxdm
    if [ -e "/usr/sbin/lxdm" ] ; then
       if [ -z "`chroot ${DESTDIR} getent group "lxdm" 2> /dev/null`" ]; then
         chroot ${DESTDIR} groupadd lxdm  &>/dev/null
         chroot ${DESTDIR} chown root:lxdm /etc/lxdm/lxdm.conf  &>/dev/null
       fi
       if [ -e "/bootmnt/manjaro/${arch}/xfce-image.sqfs" ] ; then
         sed -i -e 's|^.*session=.*|session=/usr/bin/startxfce4|' ${DESTDIR}/etc/lxdm/lxdm.conf &>/dev/null
       fi
       chown root:lxdm ${DESTDIR}/etc/lxdm/lxdm.conf  &>/dev/null
       chown -R root:lxdm ${DESTDIR}/var/lib/lxdm  &>/dev/null
       chmod +r ${DESTDIR}/etc/lxdm/lxdm.conf &>/dev/null
    fi

    # setup kdm
    if [ -e "/usr/bin/kdm" ] ; then
       chroot ${DESTDIR} getent group kdm >/dev/null 2>&1 || groupadd -g 135 kdm &>/dev/null
       chroot ${DESTDIR} getent passwd kdm >/dev/null 2>&1 || useradd -u 135 -g kdm -d /var/lib/kdm -s /bin/false -r -M kdm &>/dev/null
       chroot ${DESTDIR} chown -R 135:135 var/lib/kdm &>/dev/null
       chroot ${DESTDIR} xdg-icon-resource forceupdate --theme hicolor &> /dev/null
       chroot ${DESTDIR} update-desktop-database -q
    fi

    # fix some apps

    DIALOG --infobox "${_fixapps}" 6 40
    sleep 3

    #fix_gnome_apps
    chroot ${DESTDIR} glib-compile-schemas /usr/share/glib-2.0/schemas
    chroot ${DESTDIR} gtk-update-icon-cache -q -t -f /usr/share/icons/hicolor
    chroot ${DESTDIR} dconf update

    if [ -e "/usr/bin/gnome-keyring-daemon" ] ; then
       chroot ${DESTDIR} setcap cap_ipc_lock=ep /usr/bin/gnome-keyring-daemon &>/dev/null
    fi

    #fix_ping_installation
    chroot ${DESTDIR} setcap cap_net_raw=ep /usr/bin/ping &>/dev/null
    chroot ${DESTDIR} setcap cap_net_raw=ep /usr/bin/ping6 &>/dev/null

    chroot_umount
}

set_passwd()
{
    # trap tmp-file for passwd
    trap "rm -f ${ANSWER}" 0 1 2 5 15
 
    # get password
    DIALOG --title "$_passwdtitle" \
    --clear \
    --insecure \
    --passwordbox "$_passwddl $PASSWDUSER" 10 30 2> ${ANSWER}
    PASSWD="$(cat ${ANSWER})"
    DIALOG --title "$_passwdtitle" \
    --clear \
    --insecure \
    --passwordbox "$_passwddl2 $PASSWDUSER" 10 30 2> ${ANSWER}
    PASSWD2="$(cat ${ANSWER})"
    if [ "$PASSWD" == "$PASSWD2" ]; then
       PASSWD=$PASSWD
       _passwddl=$_passwddl1
    else
       _passwddl=$_passwddl3
       set_passwd
    fi
}

# auto_fstab()
# preprocess fstab file
# comments out old fields and inserts new ones
# according to partitioning/formatting stage
#
auto_fstab(){
    # Modify fstab
    if [[ "${S_MKFS}" = "1" || "${S_MKFSAUTO}" = "1" ]]; then
        if [[ -f /tmp/.device-names ]]; then
            sort /tmp/.device-names >>${DESTDIR}/etc/fstab
        fi
        if [[ -f /tmp/.fstab ]]; then
            # clean fstab first from /dev entries
            sed -i -e '/^\/dev/d' ${DESTDIR}/etc/fstab
            sort /tmp/.fstab >>${DESTDIR}/etc/fstab
        fi
    fi
}

# list all net devices with mac adress
net_interfaces() {
    for i in $(ls /sys/class/net); do 
        echo "$i $(cat /sys/class/net/$i/address)"
    done
}

# donetwork()
# Hand-hold through setting up networking
#
# args: none
# returns: 1 on failure
donetwork() {
    NETPARAMETERS=""
    while [[ "${NETPARAMETERS}" = "" ]]; do
        # select network interface
        INTERFACE=
        S_DHCP=
        ifaces=$(net_interfaces)
        while [[ "${INTERFACE}" = "" ]]; do
            DIALOG --ok-label "Select" --menu "Select a network interface" 14 55 7 ${ifaces} 2>${ANSWER}
            case $? in
                1) return 1 ;;
                0) INTERFACE=$(cat ${ANSWER}) ;;
            esac
        done
        # wireless switch
        CONNECTION=""
        WLAN_HIDDEN=""
        WLAN_HEX=""
        WLAN_ESSID=""
        WLAN_SECURITY=""
        WLAN_KEY=""
        DIALOG --defaultno --yesno "Is your network device wireless?" 5 40
        if [[ $? -eq 0 ]]; then
            CONNECTION="wireless"
            DIALOG --defaultno --yesno "Is your wireless ESSID hexadecimal?" 5 40
            [[ $? -eq 0 ]] && WLAN_HEX="yes"
            DIALOG --inputbox "Enter your ESSID" 7 40 "MyNetwork" 2>${ANSWER} || return 1
            WLAN_ESSID=$(cat ${ANSWER})
            DIALOG --defaultno --yesno "Is your wireless network hidden?" 5 40
            [[ $? -eq 0 ]] && WLAN_HIDDEN="yes"
            DIALOG --yesno "Is your wireless network encrypted?" 5 40
            if [[ $? -eq 0 ]]; then
                while [[ "${WLAN_SECURITY}" = "" ]]; do
                DIALOG --ok-label "Select" --menu "Select encryption type" 9 40 7 \
                    "wep" "WEP encryption" \
                    "wpa" "WPA encryption" 2>${ANSWER}
                    case $? in
                        1) return 1 ;;
                        0) WLAN_SECURITY=$(cat ${ANSWER}) ;;
                    esac
                done
                DIALOG --inputbox "Enter your KEY" 5 40 "WirelessKey" 2>${ANSWER} || return 1
                WLAN_KEY=$(cat ${ANSWER})
            else
                WLAN_SECURITY="open"
            fi
        else
            CONNECTION="ethernet"
        fi
        # dhcp switch
        IP=""
        DHCLIENT=""
        DIALOG --yesno "Do you want to use DHCP?" 5 40
        if [[ $? -eq 0 ]]; then
            IP="dhcp"
            DIALOG --defaultno --yesno "Do you want to use dhclient instead of dhcpcd?" 5 55
            [[ $? -eq 0 ]] && DHCLIENT="yes"
            S_DHCP=1
        else
            IP="static"
            DIALOG --inputbox "Enter your IP address" 7 40 "192.168.1.23" 2>${ANSWER} || return 1
            IPADDR=$(cat ${ANSWER})
            DIALOG --inputbox "Enter your gateway" 7 40 "192.168.1.1" 2>${ANSWER} || return 1
            GW=$(cat ${ANSWER})
            DIALOG --inputbox "Enter your DNS server IP" 7 40 "192.168.1.1" 2>${ANSWER} || return 1
            DNS=$(cat ${ANSWER})
        fi
        DIALOG --yesno "Are these settings correct?\n\nInterface:    ${INTERFACE}\nConnection:   ${CONNECTION}\nESSID in hexadecimal: ${WLAN_HEX}\nESSID:      ${WLAN_ESSID}\nHidden:     ${WLAN_HIDDEN}\nEncryption: ${WLAN_SECURITY}\nKey:        ${WLAN_KEY}\ndhcp or static: ${IP}\nUse dhclient:   ${DHCLIENT}\nIP address: ${IPADDR}\nGateway:    ${GW}\nDNS server: ${DNS}" 0 0
        case $? in
            1) ;;
            0) NETPARAMETERS="1" ;;
        esac
    done
    # profile name
    NETWORK_PROFILE=""
    DIALOG --inputbox "Enter your network profile name" 7 40 "${INTERFACE}-${CONNECTION}" 2>${ANSWER} || return 1
    NETWORK_PROFILE=/etc/network.d/$(cat ${ANSWER})
    # write profile
    echo "CONNECTION='${CONNECTION}'" >${NETWORK_PROFILE}
    echo "DESCRIPTION='$NETWORK_PROFILE generated by manjaro setup'" >>${NETWORK_PROFILE}
    echo "INTERFACE='${INTERFACE}'"  >>${NETWORK_PROFILE}
    if [[ "${CONNECTION}" = "wireless" ]]; then
        echo "SECURITY='${WLAN_SECURITY}'" >>${NETWORK_PROFILE}
        [[ "${WLAN_HEX}" = "yes" ]] && echo "ESSID_TYPE='hex'" >>${NETWORK_PROFILE}
        echo "ESSID='${WLAN_ESSID}'" >>${NETWORK_PROFILE}
        echo "KEY='${WLAN_KEY}'" >>${NETWORK_PROFILE}
        [[ "${WLAN_HIDDEN}" = "yes" ]] && echo "HIDDEN=yes" >>${NETWORK_PROFILE}
    fi
    echo "IP='${IP}'" >>${NETWORK_PROFILE}
    if [[ "${IP}" = "dhcp" ]]; then
        [[ "${DHCLIENT}" = "yes" ]] && echo "DHCLIENT=yes" >>${NETWORK_PROFILE}
    else
        echo "ADDR='${IPADDR}'" >>${NETWORK_PROFILE}
        echo "GATEWAY='${GW}'" >>${NETWORK_PROFILE}
        echo "DNS=('${DNS}')" >>${NETWORK_PROFILE}
    fi
    # run netcfg
    netcfg -r $(basename ${NETWORK_PROFILE}) >${LOG}
    if [[ $? -gt 0 ]]; then
        DIALOG --msgbox "Error occured while running netcfg. (see ${LOG} for output)" 0 0
        return 1
    fi
    # http/ftp proxy settings
    DIALOG --inputbox "Enter your HTTP proxy server, for example:\nhttp://name:port\nhttp://ip:port\nhttp://username:password@ip:port\n\n Leave the field empty if no proxy is needed to install." 13 65 "" 2>${ANSWER} || return 1
    PROXY_HTTP=$(cat ${ANSWER})
    DIALOG --inputbox "Enter your FTP proxy server, for example:\nhttp://name:port\nhttp://ip:port\nhttp://username:password@ip:port\n\n Leave the field empty if no proxy is needed to install." 13 65 "" 2>${ANSWER} || return 1
    PROXY_FTP=$(cat ${ANSWER})
    if [[ "${PROXY_HTTP}" = "" ]]; then
        unset http_proxy
    else
        export http_proxy=${PROXY_HTTP}
    fi
    if [[ "${PROXY_FTP}" = "" ]]; then
        unset ftp_proxy
    else
        export ftp_proxy=${PROXY_FTP}
    fi
    DIALOG --msgbox "The network is configured." 8 30
    NEXTITEM="2"
    S_NET=1
}
 
set_language() {
    if [[ -e /etc/manjaro/lg ]]; then
        /etc/manjaro/lg --setup
    else
        DIALOG --msgbox "Error:\nlg script not found, aborting language setting" 0 0
    fi
}

set_keyboard() {
    if [[ -e /etc/manjaro/km ]]; then
        /etc/manjaro/km --setup
    else
        DIALOG --msgbox "Error:\nkm script not found, aborting keyboard and console setting" 0 0
    fi
}

# set_clock()
# prompts user to set hardware clock and timezone
#
# params: none
# returns: 1 on failure
set_clock()
{
    # utc or local?
    DIALOG --menu "${_machinetimezone}" 10 72 2 \
        "UTC" " " \
        "localtime" " " \
        2>${ANSWER} || return 1
    HARDWARECLOCK=$(cat ${ANSWER})

    # timezone?
    REGIONS=""
    for i in $(grep '^[A-Z]' /usr/share/zoneinfo/zone.tab | cut -f 3 | sed -e 's#/.*##g'| sort -u); do
      REGIONS="$REGIONS $i -"
    done
    region=""
    zone=""
    while [ -z "$zone" ];do
      region=""
      while [ -z "$region" ];do
        :>${ANSWER}
        DIALOG --menu "${_selectregion}" 0 0 0 $REGIONS 2>${ANSWER}
        region=$(cat ${ANSWER})
      done
      ZONES=""
      for i in $(grep '^[A-Z]' /usr/share/zoneinfo/zone.tab | grep $region/ | cut -f 3 | sed -e "s#$region/##g"| sort -u); do
        ZONES="$ZONES $i -"
      done
      :>${ANSWER}
      DIALOG --menu "${_selecttimezone}" 0 0 0 $ZONES 2>${ANSWER}
      zone=$(cat ${ANSWER})
    done
    TIMEZONE="$region/$zone"

    # set system clock from hwclock - stolen from rc.sysinit
    local HWCLOCK_PARAMS=""
    if [ "$HARDWARECLOCK" = "UTC" ]; then
        HWCLOCK_PARAMS="$HWCLOCK_PARAMS --utc"
    else
        HWCLOCK_PARAMS="$HWCLOCK_PARAMS --localtime"
        echo "0.0 0.0 0.0" > /etc/adjtime &> /dev/null
        echo "0" >> /etc/adjtime &> /dev/null
        echo "LOCAL" >> /etc/adjtime &> /dev/null
    fi
    if [ "$TIMEZONE" != "" -a -e "/usr/share/zoneinfo/$TIMEZONE" ]; then
        /bin/rm -f /etc/localtime
        /bin/cp "/usr/share/zoneinfo/$TIMEZONE" /etc/localtime
    fi
    /sbin/hwclock --hctosys $HWCLOCK_PARAMS --noadjfile

    # display and ask to set date/time
    DIALOG --calendar "${_choosedatetime}" 0 0 0 0 0 2> ${ANSWER} || return 1
    local _date="$(cat ${ANSWER})"
    DIALOG --timebox "${_choosehourtime}" 0 0 2> ${ANSWER} || return 1
    local _time="$(cat ${ANSWER})"
    echo "date: $_date time: $_time" >$LOG

    # save the time
    # DD/MM/YYYY hh:mm:ss -> YYYY-MM-DD hh:mm:ss
    local _datetime="$(echo "$_date" "$_time" | sed 's#\(..\)/\(..\)/\(....\) \(..\):\(..\):\(..\)#\3-\2-\1 \4:\5:\6#g')"
    echo "setting date to: $_datetime" >$LOG
    date -s "$_datetime" 2>&1 >$LOG
    /sbin/hwclock --systohc $HWCLOCK_PARAMS --noadjfile

    S_CLOCK=1
    NEXTITEM="1"
}

prepare_harddrive() {
    S_MKFSAUTO=0
    S_MKFS=0
    DONE=0
    NEXTITEM=""
    CANCEL="1"
    while [[ "${DONE}" = "0" ]]; do
        if [[ -n "${NEXTITEM}" ]]; then
            DEFAULT="--default-item ${NEXTITEM}"
        else
            DEFAULT=""
        fi
        CANCEL=""
        dialog ${DEFAULT} --backtitle "${TITLE}" --menu "Prepare Hard Drive" 12 60 5 \
            "1" "Auto-Prepare (erases the ENTIRE hard drive)" \
            "2" "Partition Hard Drives" \
            "3" "Create Software Raid, Lvm2 and Luks encryption" \
            "4" "Set Filesystem Mountpoints" \
            "5" "Return to Main Menu" 2>${ANSWER} || CANCEL="1"
        NEXTITEM="$(cat ${ANSWER})"
        [[ "${S_MKFSAUTO}" = "1" ]] && DONE=1
        case $(cat ${ANSWER}) in
            "1")
                autoprepare
                [[ "${S_MKFSAUTO}" = "1" ]] && DONE=1
                CANCEL="0"
                _hd_is_prepared=1 
                NEXTITEM="5";;
            "2")
                partition ;;
            "3")
                create_special ;;
            "4")
                PARTFINISH=""
                ASK_MOUNTPOINTS="1"
                mountpoints
                CANCEL="0"
                _hd_is_prepared=1 
                NEXTITEM="5";;
            *)
                DONE=1 ;;
        esac
    done
    if [[ "${CANCEL}" = "1" ]]; then
        NEXTITEM="2"
    else
        NEXTITEM="3"
    fi
}

# run_unsquashfs()
# runs unsquashfs on the target system, displays output
#
run_unsquashfs()
{
    # all unsquashfs output goes to /tmp/unsquashfs.log, which we tail
    # into a dialog
    ( \
        touch /tmp/setup-unsquashfs-running
        echo "unsquashing $SQF_FILE..." > /tmp/unsquashfs.log; \
        echo >> /tmp/unsquashfs.log; \
        unsquashfs -f -p 1 -d $UNSQUASH_TARGET /bootmnt/manjaro/${arch}/$SQF_FILE >>/tmp/unsquashfs.log 2>&1
        echo $? > /tmp/.unsquashfs-retcode
        echo >> /tmp/unsquashfs.log
        rm -f /tmp/setup-unsquashfs-running
    ) &

    (
    c="0"
    while [ $c -ne 100 ]
    do
        sleep 2
        value=`cat /tmp/unsquashfs.log | grep -Eo " [0-9]*%" | sed -e "s|[^0-9]||g" | tail -1`
        sleep 2
        c=$value
        echo $c
        echo "###"
        echo "$c %"
        echo "###"
    done
    ) | DIALOG --title "$_unsquash_dialog_title" --gauge "$_unsquash_dialog_info1 $SQF_FILE $_unsquash_dialog_info2" 10 60 0

    # alert the user to fatal errors
    if [ $(cat /tmp/.unsquashfs-retcode) -ne 0 ]; then
        killall unsquashfs
        DIALOG --title "$_unsquasherror_title" --exit-label \
        "OK" --textbox "/tmp/unsquashfs.log" 18 70
        return 1
    fi

    # save unsquashfs.log
    mv "/tmp/unsquashfs.log" "/tmp/unsquashfs-$SQF_FILE.log"
}

# run_mkinitcpio()
# runs mkinitcpio on the target system, displays output
#
run_mkinitcpio()
{
    chroot_mount
    # fix fsck.btrfs issue
    chroot "$DESTDIR" ln -s /bin/true /sbin/fsck.btrfs

    # fix fsck.nilfs2 issue
    chroot "$DESTDIR" ln -s /bin/true /sbin/fsck.nilfs2

    # all mkinitcpio output goes to /tmp/mkinitcpio.log, which we tail
    # into a dialog
    ( \
        touch /tmp/setup-mkinitcpio-running
        echo "${_runninginitcpio}" > /tmp/mkinitcpio.log; \
        echo >> /tmp/mkinitcpio.log; \
        chroot "$DESTDIR" /sbin/depmod >>/tmp/mkinitcpio.log 2>&1
        chroot "$DESTDIR" /usr/bin/mkinitcpio -p "$manjaro_kernel" >>/tmp/mkinitcpio.log 2>&1
        echo $? > /tmp/.mkinitcpio-retcode
        echo >> /tmp/mkinitcpio.log
        rm -f /tmp/setup-mkinitcpio-running
    ) &

    sleep 2

    DIALOG --title "${_runninginitcpiotitle}" \
        --no-kill --tailboxbg "/tmp/mkinitcpio.log" 18 70 2>${ANSWER}
    while [ -f /tmp/setup-mkinitcpio-running ]; do
        sleep 1
    done
    kill $(cat ${ANSWER})

    chroot_umount

    # alert the user to fatal errors
    if [ $(cat /tmp/.mkinitcpio-retcode) -ne 0 ]; then
        DIALOG --title "${_mkinitcpiofailerror}" --exit-label \
        "${_continue_label}" --textbox "/tmp/mkinitcpio.log" 18 70
        return 1
    fi
}

_setup_user()
{
    addgroups="video,audio,power,disk,storage,optical,network,lp,scanner"
    DIALOG --inputbox "${_enterusername}" 10 65 "manjaro" 2>${ANSWER} || return 1
    REPLY="$(cat ${ANSWER})"
    while [ -z "$(echo $REPLY |grep -E '^[a-z_][a-z0-9_-]*[$]?$')" ];do
       DIALOG --inputbox "${_givecorrectname}" 10 65 "manjaro" 2>${ANSWER} || return 1
       REPLY="$(cat ${ANSWER})"
    done

    chroot ${DESTDIR} useradd -m -p "" -g users -G $addgroups $REPLY

    PASSWDUSER="$REPLY"

    if [ -e "/bootmnt/manjaro/${arch}/gnome-image.sqfs" ] ; then
       cp /var/lib/AccountsService/users/manjaro ${DESTDIR}/var/lib/AccountsService/users/$PASSWDUSER
       cp -f /var/lib/AccountsService/users/manjaro ${DESTDIR}/var/lib/AccountsService/users/gdm
    fi

    if DIALOG --yesno "${_addsudouserdl1}${REPLY}${_addsudouserdl2}" 6 40;then
       echo "${PASSWDUSER}     ALL=(ALL) ALL" >> ${DESTDIR}/etc/sudoers
       chmod 0440 ${DESTDIR}/etc/sudoers
    fi
    set_passwd
    echo "$PASSWDUSER:$PASSWD" | chroot ${DESTDIR} chpasswd
    NEXTITEM="Setup-User"
    DONE_CONFIG=1
}

_config_system()
{
    DONE=0
    NEXTITEM=""
    while [[ "${DONE}" = "0" ]]; do
        if [[ -n "${NEXTITEM}" ]]; then
            DEFAULT="--default-item ${NEXTITEM}"
        else
            DEFAULT=""
        fi
        DIALOG $DEFAULT --menu "Configuration" 17 78 10 \
            "/etc/fstab"                "${_fstabtext}" \
            "/etc/mkinitcpio.conf"      "${_mkinitcpioconftext}" \
            "/etc/resolv.conf"          "${_resolvconftext}" \
            "/etc/hostname"             "${_hostnametext}" \
            "/etc/hosts"                "${_hoststext}" \
            "/etc/hosts.deny"           "${_hostsdenytext}" \
            "/etc/hosts.allow"          "${_hostsallowtext}" \
            "/etc/locale.gen"           "${_localegentext}" \
            "/etc/locale.conf"           "${_localeconftext}" \
            "/etc/environment"           "${_environmenttext}" \
            "/etc/pacman.d/mirrorlist"  "${_mirrorlisttext}" \
            "/etc/X11/xorg.conf.d/10-evdev.conf"  "${_xorgevdevconftext}" \
            "/etc/vconsole.conf"        "${_vconsoletext}" \
            "${_return_label}"        "${_return_label}" 2>${ANSWER} || NEXTITEM="${_return_label}"
        NEXTITEM="$(cat ${ANSWER})"

        if [ "${NEXTITEM}" = "${_return_label}" -o -z "${NEXTITEM}" ]; then       # exit
           DONE=1
        else
           $EDITOR ${DESTDIR}${NEXTITEM}
        fi
    done
}

_configure_translation_pkgs()
{
    # Determind which language we are using
    if [ -e "/bootmnt/manjaro/${arch}/lng-image.sqfs" ] ; then
	#Belarusian
	if [ "$(cat ${DESTDIR}/etc/locale.conf | grep LANG= | cut -d= -f2 | cut -d. -f1 | grep "be_BY")" != "" ]; then
	   PACMAN_LNG_INST="firefox-i18n-be thunderbird-i18n-be libreoffice-be"
	#Bulgarian
	elif [ "$(cat ${DESTDIR}/etc/locale.conf | grep LANG= | cut -d= -f2 | cut -d. -f1 | grep "bg_BG")" != "" ]; then
	   PACMAN_LNG_INST="firefox-i18n-bg thunderbird-i18n-bg libreoffice-bg"
	   PACMAN_LNG_INST_KDE="kde-l10n-bg"
	#German
	elif [ "$(cat ${DESTDIR}/etc/locale.conf | grep LANG= | cut -d= -f2 | cut -d. -f1 | grep "de")" != "" ]; then
	   PACMAN_LNG_INST="firefox-i18n-de thunderbird-i18n-de hunspell-de libreoffice-de"
	   PACMAN_LNG_INST_KDE="kde-l10n-de"
	#English
	elif [ "$(cat ${DESTDIR}/etc/locale.conf | grep LANG= | cut -d= -f2 | cut -d. -f1 | grep "en")" != "" ]; then
           PACMAN_LNG_INST="hunspell-en libreoffice-en-US"
	#British English
	elif [ "$(cat ${DESTDIR}/etc/locale.conf | grep LANG= | cut -d= -f2 | cut -d. -f1 | grep "en_GB")" != "" ]; then
           PACMAN_LNG_INST="firefox-i18n-en-gb thunderbird-i18n-en-gb libreoffice-en-GB hunspell-en"
	#Espanol
	elif [ "$(cat ${DESTDIR}/etc/locale.conf | grep LANG= | cut -d= -f2 | cut -d. -f1 | grep "es")" != "" ]; then
	   PACMAN_LNG_INST="firefox-i18n-es-es thunderbird-i18n-es-es hunspell-es libreoffice-es"
	   PACMAN_LNG_INST_KDE="kde-l10n-es"
	#Espanol (Argentina)
	elif [ "$(cat ${DESTDIR}/etc/locale.conf | grep LANG= | cut -d= -f2 | cut -d. -f1 | grep "es_AR")" != "" ]; then
	   PACMAN_LNG_INST="firefox-i18n-es-ar thunderbird-i18n-es-ar hunspell-es libreoffice-es"
	   PACMAN_LNG_INST_KDE="kde-l10n-es"
	#Francais
	elif [ "$(cat ${DESTDIR}/etc/locale.conf | grep LANG= | cut -d= -f2 | cut -d. -f1 | grep "fr")" != "" ]; then
	   PACMAN_LNG_INST="firefox-i18n-fr thunderbird-i18n-fr hunspell-fr libreoffice-fr"
	   PACMAN_LNG_INST_KDE="kde-l10n-fr"
	#Italian
	elif [ "$(cat ${DESTDIR}/etc/locale.conf | grep LANG= | cut -d= -f2 | cut -d. -f1 | grep "it")" != "" ]; then
	   PACMAN_LNG_INST="firefox-i18n-it thunderbird-i18n-it hunspell-it libreoffice-it"
	   PACMAN_LNG_INST_KDE="kde-l10n-it"
	#Polish
	elif [ "$(cat ${DESTDIR}/etc/locale.conf | grep LANG= | cut -d= -f2 | cut -d. -f1 | grep "pl_PL")" != "" ]; then
	   PACMAN_LNG_INST="firefox-i18n-pl thunderbird-i18n-pl hunspell-pl libreoffice-pl"
	   PACMAN_LNG_INST_KDE="kde-l10n-pl"
	#Brazilian Portuguese
	elif [ "$(cat ${DESTDIR}/etc/locale.conf | grep LANG= | cut -d= -f2 | cut -d. -f1 | grep "pt_BR")" != "" ]; then
	   PACMAN_LNG_INST="firefox-i18n-pt-br thunderbird-i18n-pt-br libreoffice-pt-BR"
	   PACMAN_LNG_INST_KDE="kde-l10n-pt_br"
	#Portuguese
	elif [ "$(cat ${DESTDIR}/etc/locale.conf | grep LANG= | cut -d= -f2 | cut -d. -f1 | grep "pt_PT")" != "" ]; then
	   PACMAN_LNG_INST="firefox-i18n-pt-pt thunderbird-i18n-pt-pt libreoffice-pt"
	   PACMAN_LNG_INST_KDE="kde-l10n-pt"
	#Romanian
	elif [ "$(cat ${DESTDIR}/etc/locale.conf | grep LANG= | cut -d= -f2 | cut -d. -f1 | grep "ro_RO")" != "" ]; then
	   PACMAN_LNG_INST="firefox-i18n-ro thunderbird-i18n-ro hunspell-ro libreoffice-ro"
	   PACMAN_LNG_INST_KDE="kde-l10n-ro"
	#Russian
	elif [ "$(cat ${DESTDIR}/etc/locale.conf | grep LANG= | cut -d= -f2 | cut -d. -f1 | grep "ru")" != "" ]; then
	   PACMAN_LNG_INST="firefox-i18n-ru thunderbird-i18n-ru libreoffice-ru"
	   PACMAN_LNG_INST_KDE="kde-l10n-ru"
	#Swedish
	elif [ "$(cat ${DESTDIR}/etc/locale.conf | grep LANG= | cut -d= -f2 | cut -d. -f1 | grep "sv")" != "" ]; then
	   PACMAN_LNG_INST="firefox-i18n-sv-se thunderbird-i18n-sv-se libreoffice-sv"
	   PACMAN_LNG_INST_KDE="kde-l10n-sv"
	#Turkish
	elif [ "$(cat ${DESTDIR}/etc/locale.conf | grep LANG= | cut -d= -f2 | cut -d. -f1 | grep "tr")" != "" ]; then
	   PACMAN_LNG_INST="firefox-i18n-tr thunderbird-i18n-tr libreoffice-tr"
	   PACMAN_LNG_INST_KDE="kde-l10n-tr"
	#Ukrainian
	elif [ "$(cat ${DESTDIR}/etc/locale.conf | grep LANG= | cut -d= -f2 | cut -d. -f1 | grep "uk_UA")" != "" ]; then
	   PACMAN_LNG_INST="firefox-i18n-uk thunderbird-i18n-uk libreoffice-uk"
	   PACMAN_LNG_INST_KDE="kde-l10n-uk"
	fi
    fi
}

_post_process()
{
    ## POSTPROCESSING ##
    # /etc/locale.gen
    #
    DIALOG --infobox "${_localegen}" 0 0
    chroot ${DESTDIR} locale-gen &> /dev/null

    # installing localization packages
    if [ ! -e "/bootmnt/manjaro/${arch}/kde-image.sqfs" ] ; then
       PACMAN_LNG_INST_KDE=""
    fi

    if [ -e "/bootmnt/manjaro/${arch}/lng-image.sqfs" ] ; then
       _configure_translation_pkgs
       ${PACMAN_LNG} -Sy ${PACMAN_LNG_INST} ${PACMAN_LNG_INST_KDE} &> /dev/null
    fi

    # /etc/localtime
    cp /etc/localtime ${DESTDIR}/etc/localtime &> /dev/null
    if [ -e "/etc/adjtime" ] ; then
       cp /etc/adjtime ${DESTDIR}/etc/adjtime &> /dev/null
    fi

    # sync pacman databases
    DIALOG --infobox "${_syncpacmandb}" 0 0
    sleep 3
    chroot ${DESTDIR} pacman -Syy &> /dev/null

    # create kernel images    
    run_mkinitcpio

    ## END POSTPROCESSING ##
    # TODO add end cleaning

    S_CONFIG=1
    NEXTITEM=5
    _system_is_configured=1
}

configure_system()
{
    ## PREPROCESSING ##
    # only done on first invocation of configure_system
    if [ $S_PRECONFIG -eq 0 ]; then
        #edit /etc/locale.conf & /etc/environment
        echo "LANG=${LOCALE}.UTF-8" > ${DESTDIR}/etc/locale.conf
        echo "LC_COLLATE=C" >> ${DESTDIR}/etc/locale.conf
        echo "LANG=${LOCALE}.UTF-8" >> ${DESTDIR}/etc/environment

        #edit /etc/mkinitcpio.conf to have external bootup from usb and resume support
        HOOKS=`cat /etc/mkinitcpio.conf | grep HOOKS= | grep -v '#' | cut -d'"' -f2 | sed 's/filesystems/usb fw pcmcia resume filesystems/g'`
        if [ -e ${DESTDIR}/etc/plymouth/plymouthd.conf ] ; then
           sed -i -e "s/^HOOKS=.*/HOOKS=\"${HOOKS} plymouth\"/g" ${DESTDIR}/etc/mkinitcpio.conf
        fi

        #prepare_locale_gen
        for i in $(grep "^LANG" ${DESTDIR}/etc/locale.conf | sed -e 's/.*=//g' -e's/\..*//g'); do
	    sed -i -e "s/^#$i/$i/g" ${DESTDIR}/etc/locale.gen
        done

	#enable en_US always
        if [ "$LOCALE" != "en_US.UTF-8" ]; then
        	sed -i -e "s/^#en_US/en_US/g" ${DESTDIR}/etc/locale.gen
        fi

        #do_lang_settings
        if [ -e "/bootmnt/manjaro/${arch}/lng-image.sqfs" ] ; then
             PACMAN_LNG_INST="hunspell-en libreoffice-en-US"
             PACMAN_LNG_INST_KDE=""
        fi
 	# Determind which language we are using
	if [ "$(echo "${KEYMAP}" | grep "en_US")" != "" ]; then
		# Setup system for the American language
		
		# Set American Xorg keyboard layout
		sed -i 's#Identifier "evdev keyboard catchall".*#&\n        Option "XkbLayout" "us"#'       ${DESTDIR}/etc/X11/xorg.conf.d/10-evdev.conf
                sed -i -e 's/^.*KEYMAP=.*/KEYMAP=us/' ${DESTDIR}/etc/vconsole.conf

	elif [ "$(echo "${KEYMAP}" | grep "en_GB")" != "" ]; then
		# Setup system for the British language
		
		# Set British Xorg keyboard layout
		sed -i 's#Identifier "evdev keyboard catchall".*#&\n        Option "XkbLayout" "gb"#'       ${DESTDIR}/etc/X11/xorg.conf.d/10-evdev.conf
                sed -i -e 's/^.*KEYMAP=.*/KEYMAP=uk/' ${DESTDIR}/etc/vconsole.conf

	elif [ "$(echo "${KEYMAP}" | grep "be_BY")" != "" ]; then
		# Setup system for the Belarusian language
		
		# Set Belarusian Xorg keyboard layout
		sed -i 's#Identifier "evdev keyboard catchall".*#&\n        Option "XkbLayout" "be"#' ${DESTDIR}/etc/X11/xorg.conf.d/10-evdev.conf
                sed -i -e 's/^.*KEYMAP=.*/KEYMAP=be/' ${DESTDIR}/etc/vconsole.conf

	elif [ "$(echo "${KEYMAP}" | grep "pt_BR")" != "" ]; then
		# Setup system for the Brazilian language
		
		# Set Brazilian Xorg keyboard layout
		sed -i 's#Identifier "evdev keyboard catchall".*#&\n        Option "XkbLayout" "br-abnt2"#'       ${DESTDIR}/etc/X11/xorg.conf.d/10-evdev.conf
                sed -i -e 's/^.*KEYMAP=.*/KEYMAP=br-abnt2/' ${DESTDIR}/etc/vconsole.conf

	elif [ "$(echo "${KEYMAP}" | grep "bg_BG")" != "" ]; then
		# Setup system for the Bulgarian language
		
		# Set Bulgarian Xorg keyboard layout
		sed -i 's#Identifier "evdev keyboard catchall".*#&\n        Option "XkbLayout" "bg"#'       ${DESTDIR}/etc/X11/xorg.conf.d/10-evdev.conf
                sed -i -e 's/^.*KEYMAP=.*/KEYMAP=bg/' ${DESTDIR}/etc/vconsole.conf

	elif [ "$(echo "${KEYMAP}" | grep "da_DK")" != "" ]; then
		# Setup system for the Danish language
		
		# Set Danish Xorg keyboard layout
		sed -i 's#Identifier "evdev keyboard catchall".*#&\n        Option "XkbLayout" "dk"#'       ${DESTDIR}/etc/X11/xorg.conf.d/10-evdev.conf
                sed -i -e 's/^.*KEYMAP=.*/KEYMAP=dk/' ${DESTDIR}/etc/vconsole.conf

	elif [ "$(echo "${KEYMAP}" | grep "fr_BE")" != "" ]; then
		# Setup system for the Belgian language
		
		# Set Belgian Xorg keyboard layout
		sed -i 's#Identifier "evdev keyboard catchall".*#&\n        Option "XkbLayout" "be-latin1"#'       ${DESTDIR}/etc/X11/xorg.conf.d/10-evdev.conf
                sed -i -e 's/^.*KEYMAP=.*/KEYMAP=be-latin1/' ${DESTDIR}/etc/vconsole.conf

	elif [ "$(echo "${KEYMAP}" | grep "fr_FR")" != "" ]; then
		# Setup system for the French language
		
		# Set French Xorg keyboard layout
		sed -i 's#Identifier "evdev keyboard catchall".*#&\n        Option "XkbLayout" "fr"#'       ${DESTDIR}/etc/X11/xorg.conf.d/10-evdev.conf
                sed -i -e 's/^.*KEYMAP=.*/KEYMAP=fr/' ${DESTDIR}/etc/vconsole.conf

	elif [ "$(echo "${KEYMAP}" | grep "fr_CA")" != "" ]; then
		# Setup system for the French Canada language
		
		# Set French Canada Xorg keyboard layout
		sed -i 's#Identifier "evdev keyboard catchall".*#&\n        Option "XkbLayout" "cf"#'       ${DESTDIR}/etc/X11/xorg.conf.d/10-evdev.conf
                sed -i -e 's/^.*KEYMAP=.*/KEYMAP=cf/' ${DESTDIR}/etc/vconsole.conf

	elif [ "$(echo "${KEYMAP}" | grep "de_DE")" != "" ]; then
		# Setup system for the German language
		
		# Set German Xorg keyboard layout
		sed -i 's#Identifier "evdev keyboard catchall".*#&\n        Option "XkbLayout" "de"\n        Option "XkbVariant" "nodeadkeys"#' ${DESTDIR}/etc/X11/xorg.conf.d/10-evdev.conf
                sed -i -e 's/^.*KEYMAP=.*/KEYMAP=de/' ${DESTDIR}/etc/vconsole.conf

	elif [ "$(echo "${KEYMAP}" | grep "is_IS")" != "" ]; then
		# Setup system for the Icelandic language
		
		# Set Icelandic Xorg keyboard layout
		sed -i 's#Identifier "evdev keyboard catchall".*#&\n        Option "XkbLayout" "is"#'       ${DESTDIR}/etc/X11/xorg.conf.d/10-evdev.conf
                sed -i -e 's/^.*KEYMAP=.*/KEYMAP=is/' ${DESTDIR}/etc/vconsole.conf

	elif [ "$(echo "${KEYMAP}" | grep "it_IT")" != "" ]; then
		# Setup system for the Italian language
		
		# Set Italian Xorg keyboard layout
		sed -i 's#Identifier "evdev keyboard catchall".*#&\n        Option "XkbLayout" "it"#'       ${DESTDIR}/etc/X11/xorg.conf.d/10-evdev.conf
                sed -i -e 's/^.*KEYMAP=.*/KEYMAP=it/' ${DESTDIR}/etc/vconsole.conf

	elif [ "$(echo "${KEYMAP}" | grep "nn_NO")" != "" ]; then
		# Setup system for the Nynorsk language
		
		# Set Nynorsk Xorg keyboard layout
		sed -i 's#Identifier "evdev keyboard catchall".*#&\n        Option "XkbLayout" "no"#'       ${DESTDIR}/etc/X11/xorg.conf.d/10-evdev.conf
                sed -i -e 's/^.*KEYMAP=.*/KEYMAP=no-latin1/' ${DESTDIR}/etc/vconsole.conf

	elif [ "$(echo "${KEYMAP}" | grep "pl_PL")" != "" ]; then
		# Setup system for the Polish language
		
		# Set Polish Xorg keyboard layout
		sed -i 's#Identifier "evdev keyboard catchall".*#&\n        Option "XkbLayout" "pl"#'       ${DESTDIR}/etc/X11/xorg.conf.d/10-evdev.conf
                sed -i -e 's/^.*KEYMAP=.*/KEYMAP=pl/' ${DESTDIR}/etc/vconsole.conf

	elif [ "$(echo "${KEYMAP}" | grep "pt_PT")" != "" ]; then
		# Setup system for the Portuguese language
		
		# Set Portuguese Xorg keyboard layout
		sed -i 's#Identifier "evdev keyboard catchall".*#&\n        Option "XkbLayout" "pt"#'       ${DESTDIR}/etc/X11/xorg.conf.d/10-evdev.conf
                sed -i -e 's/^.*KEYMAP=.*/KEYMAP=pt/' ${DESTDIR}/etc/vconsole.conf

	elif [ "$(echo "${KEYMAP}" | grep "ro_RO")" != "" ]; then
		# Setup system for the Romanian language
		
		# Set Romanian Xorg keyboard layout
		sed -i 's#Identifier "evdev keyboard catchall".*#&\n        Option "XkbLayout" "ro"#'       ${DESTDIR}/etc/X11/xorg.conf.d/10-evdev.conf
                sed -i -e 's/^.*KEYMAP=.*/KEYMAP=ro/' ${DESTDIR}/etc/vconsole.conf

	elif [ "$(echo "${KEYMAP}" | grep "ru_RU")" != "" ]; then
		# Setup system for the Russian language
		
		# Set Russian Xorg keyboard layout
		sed -i 's#Identifier "evdev keyboard catchall".*#&\n        Option "XkbLayout" "ru"#'       ${DESTDIR}/etc/X11/xorg.conf.d/10-evdev.conf
                sed -i -e 's/^.*KEYMAP=.*/KEYMAP=ru/' ${DESTDIR}/etc/vconsole.conf

	elif [ "$(echo "${KEYMAP}" | grep "es_AR")" != "" ]; then
		# Setup system for the Argentinian language
		
		# Set Argentinian Xorg keyboard layout
		sed -i 's#Identifier "evdev keyboard catchall".*#&\n        Option "XkbLayout" "la-latin1"#'       ${DESTDIR}/etc/X11/xorg.conf.d/10-evdev.conf
                sed -i -e 's/^.*KEYMAP=.*/KEYMAP=la-latin1/' ${DESTDIR}/etc/vconsole.conf

	elif [ "$(echo "${KEYMAP}" | grep "es_ES")" != "" ]; then
		# Setup system for the Spanish language
		
		# Set Spanish Xorg keyboard layout
		sed -i 's#Identifier "evdev keyboard catchall".*#&\n        Option "XkbLayout" "es"#'       ${DESTDIR}/etc/X11/xorg.conf.d/10-evdev.conf
                sed -i -e 's/^.*KEYMAP=.*/KEYMAP=es/' ${DESTDIR}/etc/vconsole.conf

	elif [ "$(echo "${KEYMAP}" | grep "sv_SE")" != "" ]; then
		# Setup system for the Swedish language
		
		# Set Swedish Xorg keyboard layout
		sed -i 's#Identifier "evdev keyboard catchall".*#&\n        Option "XkbLayout" "sv-latin1"#'       ${DESTDIR}/etc/X11/xorg.conf.d/10-evdev.conf
                sed -i -e 's/^.*KEYMAP=.*/KEYMAP=sv-latin1/' ${DESTDIR}/etc/vconsole.conf

	elif [ "$(echo "${KEYMAP}" | grep "tr_TR")" != "" ]; then
		# Setup system for the Turkish language
		
		# Set Turkish Xorg keyboard layout
		sed -i 's#Identifier "evdev keyboard catchall".*#&\n        Option "XkbLayout" "tr"#'       ${DESTDIR}/etc/X11/xorg.conf.d/10-evdev.conf
                sed -i -e 's/^.*KEYMAP=.*/KEYMAP=trq/' ${DESTDIR}/etc/vconsole.conf

	elif [ "$(echo "${KEYMAP}" | grep "uk_UA")" != "" ]; then
		# Setup system for the Ukrainian language
		
		# Set Ukrainian Xorg keyboard layout
		sed -i 's#Identifier "evdev keyboard catchall".*#&\n        Option "XkbLayout" "ua"#'       ${DESTDIR}/etc/X11/xorg.conf.d/10-evdev.conf
                sed -i -e 's/^.*KEYMAP=.*/KEYMAP=ua/' ${DESTDIR}/etc/vconsole.conf
	fi
    fi

    S_PRECONFIG=1
    ## END PREPROCESS ##

    DONE=0
    DONE_CONFIG=""
    NEXTITEM=""
    while [[ "${DONE}" = "0" ]]; do
        if [[ -n "${NEXTITEM}" ]]; then
            DEFAULT="--default-item ${NEXTITEM}"
        else
            DEFAULT=""
        fi

        DIALOG $DEFAULT --menu "Configuration" 17 78 10 \
            "Root-Password"             "${_definerootpass}" \
            "Setup-User"                "${_defineuser}" \
            "Setup-Locale"              "${_definelocale}" \
            "Setup-Keymap"              "${_definekeymap}" \
            "Config-System"             "${_doeditconfig}" \
            "${_return_label}"          "${_mainmenulabel}" 2>${ANSWER} || NEXTITEM="${_return_label}"
        NEXTITEM="$(cat ${ANSWER})"

        case $(cat ${ANSWER}) in
            "Root-Password")
                PASSWDUSER="root"
                set_passwd
                echo "$PASSWDUSER:$PASSWD" | chroot ${DESTDIR} chpasswd
                DONE_CONFIG="1"
                NEXTITEM="Setup-User" ;;
            "Setup-User")
                _setup_user && NEXTITEM="Setup-User" ;;
            "Setup-Locale")
                set_language && NEXTITEM="Setup-Locale" ;;
            "Setup-Keymap")
                set_keyboard && NEXTITEM="Setup-Keymap" ;;
            "Config-System")
                _config_system && NEXTITEM="${_return_label}" ;;
            "${_return_label}")
                DONE="1" ;;
             *)
                DONE="1" ;;
        esac
    done
    if [[ "${DONE_CONFIG}" = "1" ]]; then
       _post_process
    else
       NEXTITEM="4"
    fi
}

mainmenu()
{
    if [ -n "${NEXTITEM}" ]; then
        DEFAULT="--default-item ${NEXTITEM}"
    else
        DEFAULT=""
    fi
    DIALOG $DEFAULT --title " ${_mainmenulabel} " \
        --menu "${_mainmenuhelp}" 16 55 8 \
        "0" "${_datetimetext}" \
        "1" "${_networktext}" \
        "2" "${_preparediskstext}" \
        "3" "${_installsystemtext}" \
        "4" "${_configuresystemtext}" \
        "5" "${_instbootloadertext}" \
        "6" "${_quittext}" 2>${ANSWER}
    NEXTITEM="$(cat ${ANSWER})"
    case $(cat ${ANSWER}) in
        "0")
            set_clock ;;
        "1")
            donetwork ;;
        "2")
            prepare_harddrive
        ;;
        "3")
            if [ "$_hd_is_prepared" == "1" ];then
             installsystem
            else
             DIALOG --msgbox "$_forgotpreparehd" 10 40
            fi
        ;;
        "4")
            if [ "$_system_is_installed" == "1" ];then
             configure_system
            else 
             DIALOG --msgbox "$_forgotinstalling" 10 40
            fi
        ;;
        "5")
            if [ "$_system_is_configured" == "1" ];then
             install_bootloader
            else
             DIALOG --msgbox "$_forgotsystemconf" 10 40
            fi
        ;;
        "6")
            DIALOG --infobox "${_installationfinished}" 6 40
            mkdir -p ${DESTDIR}/var/log/manjaroiso
            cp /tmp/*.log ${DESTDIR}/var/log/manjaroiso &>/dev/null
            cp /var/log/pacman.log ${DESTDIR}/var/log/manjaroiso/pacman-live.log &>/dev/null
            _umountall &>/dev/null ; sleep 1 ; exit 0
        ;;
        *)
            if DIALOG --yesno "${_cancelinstall}" 6 40;then
            _umountall &>/dev/null ; exit 0
            fi
        ;;
    esac
}

#####################
## begin execution ##

# do UID checking here so someone can at least get usage instructions
if [ "$EUID" != "0" ]; then
    echo "error: This script must be run as root."
    exit 1
fi

# force to use english
export LANG=en_US.UTF-8
export LC_MESSAGES=en_US.UTF-8

MISOVAR="$(kernel_cmdline misovar lang:en_US,keymap:en_US,timezone:Canada/Pacific)"
LOCALE="$(echo "$MISOVAR" | cut -d, -f1 | cut -d: -f2)"
KEYMAP="$(echo "$MISOVAR" | cut -d, -f2 | cut -d: -f2)"
TIMEZONE="$(echo "$MISOVAR" | cut -d, -f3 | cut -d: -f2)"
VIDEO="$(echo "$MISOVAR" | cut -d, -f4 | cut -d: -f2)"
COMPOSITE="$(echo "$MISOVAR" | cut -d, -f5 | cut -d: -f2)"
CONSOLEFONT="$(kernel_cmdline vconsole.font)"
CONSOLEMAP="$(kernel_cmdline vconsole.font.map)"
USENONFREE="$(kernel_cmdline nonfree no)"

DIALOG --msgbox "${_instwelcomemessage}" 12 65

while true; do
    mainmenu
done

exit 0
